#!/usr/bin/perl
######################################################################
# Copyright (c) 2014-2015 Turishev Evgeniy <ew_turi@mail.ru>
# This file is licensed under the GNU General Public License version 3
# or any later version.
#######################################################################

my $main_title  = 'dir-comp';
my $open_helper = 'exo-open';
my $editor      = 'leafpad';

our $VERSION='1.01';

show_version () if $ARGV[0] eq '-v' or $ARGV[0] eq '--version';

#######################################################################
{
  package Result_List;

  use utf8;
  use Glib qw/TRUE FALSE/;
  use Gtk2::SimpleList;
  use File::Basename;

  my @clmns = ({id=>'name',    caption=>::text ('name'),  type=>'text', align=> 0},
	       {id=>'diff',    caption=>::text ('diff'),  type=>'text', align=> 0.5},
	       {id=>'a_cp',    caption=>'A->B',  type=>'bool', align=> 0.5},
	       {id=>'a_del',   caption=>'del A', type=>'bool', align=> 0.5},
	       {id=>'b_cp',    caption=>'B->A',  type=>'bool', align=> 0.5},
	       {id=>'b_del',   caption=>'del B', type=>'bool', align=> 0.5},
	       {id=>'size_a',  caption=>::text ('size A'),type=>'text', align=> 1},
	       {id=>'size_b',  caption=>::text ('size B'),type=>'text', align=> 1},
	       {id=>'time_a',  caption=>::text ('time A'),type=>'text', align=> 0},
	       {id=>'time_b',  caption=>::text ('time B'),type=>'text', align=> 0},
	       {id=>'perm_a',  caption=>::text ('perm A'),type=>'text', align=> 0},
	       {id=>'perm_b',  caption=>::text ('perm B'),type=>'text', align=> 0},
	       {id=>'owner_a', caption=>::text ('own A'), type=>'text', align=> 0},
	       {id=>'owner_b', caption=>::text ('own B'), type=>'text', align=> 0});

  my %clm; # index columns numbers on id
  for (my $i = 0; $i <= $#clmns; $i++) {
    $clm{$clmns[$i]{id}} = $i;
  }

  my $list;
  my $scroll;
  my @save_selection;

  $list = Gtk2::SimpleList->new (map {($_->{caption}, $_->{type})} @clmns);
  #$list->signal_connect('' => \&Result_List::list_click_hnd);

  for (my $i = 0; $i <= $#clmns; $i++) {
    my $clm = $list -> get_column ($i);
    $clm->set_clickable(TRUE);
    $clm->set_resizable(TRUE);
    $clm->set_sort_column_id($i);

    $clm->signal_connect('clicked', Result_List::click_column_hnd);

    my $r = $clm->get_cell_renderers;


    $r->set('xalign', $clmns[$i]{align});
    if ($clmns[$i]{type} eq 'bool') {
      $r->signal_connect ('toggled' => Result_List::check_box_hnd);
      $clm->set_cell_data_func ($r, \&bool_randr_func);
    }
  }

  $list->get_selection->set_mode ('multiple');
  $list->get_selection->signal_connect ('changed' =>\&Result_List::sel_change_hnd);
  $list->get_model->set_sort_func (8, \&Result_List::sort_int, 8);# sort size A
  $list->get_model->set_sort_func (9, \&Result_List::sort_int, 9);# sort size B

  $scroll = Gtk2::ScrolledWindow->new;
  $scroll -> set_policy ('automatic', 'automatic');
  $scroll -> add ($list);

  $list->signal_connect('button-press-event' => sub {
			  my ($widget,$event) = @_;
			  if ($event->button == 3) {
			    my @sel = Result_List::selected_inx();
			    return TRUE if $#sel > 0;
			    # not propogate event in list
			  }
			  else {FALSE};});

 # restore selection after check box clicked 
 sub sel_change_hnd {
   #my $selection = shift;
   $list->select (@save_selection);
   @save_selection = ();
 }

  # on any cell rendering
 sub bool_randr_func {
    my ($column, $renderer, $model, $iter) = @_;
    my $col = $renderer->{column_index};
    my $id = $clmns[$col]{id};
    my $dtype  = ($model->get ($iter))[$clm{diff}];

    if ($dtype eq 'A' and ($id eq 'b_del' or $id eq 'b_cp')
        or $dtype eq 'B' and ($id eq 'a_del' or $id eq 'a_cp')) {
      $renderer->set('visible' , FALSE);
    }
    else {
      #$renderer->set('inconsistent' , TRUE);
      $renderer->set('visible' , TRUE);
    }
  }

  sub sort_int {
    my $col_num = pop;
    my ($list, @iter) = @_;
    @iter = map {$_ = $list->get($_, $col_num); $_=~s/_//g; $_} @iter;
    return ($iter[0] <=> $iter[1]);
  }

  sub click_column_hnd {
    my ($widget, $data) = @_;
    # print "click_column_hnd\n";
  }

  sub check_box_hnd {
    my ($renderer, $row) = @_;
    my $col = $renderer->{column_index};
    my $model = $list->get_model;
    #print "check_box_hnd:$row,$col\n";

    @save_selection = selected_inx();#save to restore
    my $check_on_sel = 0;

    for my $k (@save_selection) {
      if ($k == $row) {
        # click on in selection area
	$check_on_sel = 1;
	last;
      }
    }

    if ($check_on_sel) {
      $val = $list->{data}->[$row]->[$col];

      if ($#save_selection > 0
	  and $row >= $save_selection[0]
	  and $row <= $save_selection[$#save_selection]) {

	for my $i (@save_selection) {
	  if (col_visible ($i, $col))   {
	    $list->{data}->[$i]->[$col] = $val;
	  }
	}
      }
    }
    else {@save_selection = ()} # delete seletion
  }

  sub clear {
    $list->get_model->clear;
  }

  # добавление результата в список найденного
  sub add {
    my ($name, $info_a, $info_b, $diff) = @_;
    my ($status);

    $name =~ s/^\///;

    $status = $diff;

    # if ($status ne 'A' and $status ne 'B') {
    # 	$status .= ($info_a->{perm} ne  $info_b->{perm} ?'p':'')
    # 	  . ($info_a->{owner} ne  $info_b->{owner} ?'o':'');
    # }

    my @data;
    $data[$clm{name}]    = $name;
    $data[$clm{diff}]    = $status;
    $data[$clm{size_a}]  = $info_a->{size};
    $data[$clm{size_b}]  = $info_b->{size};
    $data[$clm{time_a}]  = $info_a->{mtime};
    $data[$clm{time_b}]  = $info_b->{mtime};
    $data[$clm{perm_a}]  = $info_a->{perm};
    $data[$clm{perm_b}]  = $info_b->{perm};
    $data[$clm{owner_a}] = $info_a->{owner};
    $data[$clm{owner_b}] = $info_b->{owner};
    $data[$clm{a_del}]   = FALSE;
    $data[$clm{b_del}]   = FALSE;
    $data[$clm{a_cp}]    = FALSE;
    $data[$clm{b_cp}]    = FALSE;

    push @{$list->{data}}, [@data];
  }

  sub get_oper_inx_list {
    my $result = shift;
    my $l = $list->{data};
    my $c = row_count();

    for (my $i = 0; $i < $c; $i++) {
      push @$result, $i if $l->[$i]->[$clm{a_del}]
      	or $l->[$i]->[$clm{b_del}]
      	  or $l->[$i]->[$clm{a_cp}]
      	    or $l->[$i]->[$clm{b_cp}];
    }
  }

  sub selected_inx_0 {
    my @sel = $list->get_selected_indices();
    return $sel[0];
  }

  sub selected_inx {
    return $list->get_selected_indices();
  }

  # имя выбранного файла
  sub selected_name {
    my $inx = selected_inx_0();
    return @{$list->{data}}[$inx]->[$clm{name}];
  }

  sub diff_type {
    my $inx = shift;
    return @{$list->{data}}[$inx]->[$clm{diff}];
  }

  sub name {
    return @{$list->{data}}[shift]->[$clm{name}];
  }

  sub row {
    my $inx = shift;
    return map {$_ => @{$list->{data}}[$inx]->[$clm{$_}]} keys %clm;
  }

  sub delete_item {
    my $n = shift;
    splice @{$list->{data}}, $n, 1;
  }

  sub grab_focus {
    $list->grab_focus;
  }

  sub row_count {
    return $#{$list->{data}} + 1;
  }

  sub box {
    return $scroll;
  }

  sub col_visible {
    my ($row, $col) = @_;
    my $dtype = $list->{data}->[$row]->[$clm{diff}];
    return ($dtype ne 'B' or $col != $clm{'a_cp'} and $col != $clm{a_del})
       	  and
       	  ($dtype ne 'A' or $col != $clm{b_cp} and $col != $clm{b_del});
  }

  sub set_checks_for_dir {
    my $path = shift;
    my @checks = @_;

    for (my $i = 0; $i <= $#{$list->{data}}; $i++) {
      my $p = substr $list->{data}->[$i]->[$clm{name}], 0, length $path;

      if ($p eq $path) {
	#print $list->{data}->[$i]->[$clm{name}],  "\n";
        for my $c ('a_cp', 'a_del', 'b_cp', 'b_del') {
	  $list->{data}->[$i]->[$clm{$c}] = FALSE;
	}

        for my $c (@checks) {
	  if (col_visible ($i, $clm{$c})) {
	    $list->{data}->[$i]->[$clm{$c}] = TRUE;
	  }
	}
      }
    }
  }
}

# END Result_List ####################################################

package Menu;
use utf8;
use Glib qw/TRUE FALSE/;

sub create {
  my $menu = Gtk2::Menu->new;

 # $menu->append (Gtk2::TearoffMenuItem->new);

  while (my $i = shift) {
    my ($item, $name, $handler, $opt);
    $name = $i->{caption};
    $handler = $i->{handler} if exists $i->{handler};

    if (exists $i->{opt}) {
      $opt = $i->{opt}
    }
    else {$opt = 0};

    if ($name eq '---') {
      $item = Gtk2::SeparatorMenuItem->new ();
    }
    else {
      $item = Gtk2::MenuItem->new_with_label (::text ($name));
      $item->signal_connect ('activate' => $handler);
      $item->set_property ('name', $name);
    }

    $item->set_property ('user-data', $opt);
    $menu->append ($item);
  }
  $menu->signal_connect ('hide' => \&Menu::hide);
  $menu->show_all;
  return $menu;
}

sub show {
  my ($menu, $check_callback) = @_;
  my @list = $menu->get_children;

  for my $i (@list) {
    my $ud = $i->get_property ('user-data');
    next if not $ud;

    if (! &$check_callback ($ud)) {
      $i->set_sensitive (FALSE);
    }
  }
  $menu->popup (undef, undef, undef, undef, 0, 0);
}

sub hide {
  my ($menu, $event) = @_;
  my @list = $menu->get_children;
  for my $i (@list) {
    $i->set_sensitive (TRUE);
  }
}

# END Menu ###########################################################
package Dir_Box;
use utf8;
use Glib qw/TRUE FALSE/;

sub new {
  my $class = shift;
  my %opt = @_;

  my $self = {};
  bless ($self, $class);
  $self->{label} = $opt{label};

  my $hbox = Gtk2::HBox->new();
  my $entry = Gtk2::Entry->new;
  $hbox -> pack_end ($entry, TRUE, TRUE, 0);

  my $lb = Gtk2::Label->new ($self->{label});
  $hbox->pack_start ($lb, FALSE, TRUE, 0);

  my $hb  = Gtk2::HBox->new();
  if (exists $opt {butt_size}) {
    $hb->set_size_request ($opt {butt_size});
  }
  else {$hb->set_size_request (120)}

  $hbox -> pack_start ($hb, FALSE, FALSE, 0);

  my $butt = Gtk2::Button->new (' DIR');
  $hb->pack_start ($butt, TRUE, TRUE, 0);
  $butt->signal_connect (clicked => \&Dir_Box::file_dialog_run, $self);

  if (not exists $opt {sftp_disable} or not $opt {sftp_disable}) {
    my $butt = Gtk2::Button->new ('SFTP');
    $hb->pack_start ($butt, TRUE, TRUE, 0);
    $butt->signal_connect (clicked => \&Dir_Box::sftp_run, $self);
  }

  $self->{protocol_label} = Gtk2::Label->new ();
  $hbox->pack_start ($self->{protocol_label}, FALSE, TRUE, 0);
  $self->{entry} = $entry;
  $self->{box}   = $hbox;
  $self->{sftp}  = undef;
  $self->{sftp_host} = '';
  $self->{sftp_port} = '';
  $self->{sftp_login} = '';
  $self->{sftp_password} = '';

  return  $self;
}

sub file_dialog_run {
  my ($widget, $self) = @_;
  my $caption = $self->{label};

  my $dialog = Gtk2::FileChooserDialog->new
    (::text ('Select dir') . ' ' . $caption,
     undef,
     'select-folder',
     'gtk-ok'     => 'ok',
     'gtk-cancel' => 'cancel');

  my $filter = Gtk2::FileFilter->new;
  $filter->add_mime_type ('inode/directory');

  $dialog->set_filter ($filter);

  if ( $dialog->run eq 'ok') {
    $self->{entry}->set_text ($dialog->get_filename);
    $self->sftp_disconnect();
  }
  $dialog->destroy;
}

sub tree_path {
  my ($tree_view, $iter) = @_;
  my $model = $tree_view->get_model();
  my $dir_path;

  while ($iter) {
    my $name = $model->get_value ($iter);
    $dir_path = $name . '/' . $dir_path;
    $iter = $model->iter_parent ($iter);
  }
  return '/' . $dir_path;
}

sub sftp_ls {
  my ($sftp, $dir) = @_;
  my $ls = $sftp->ls ($dir ,
		      wanted => sub {my $n=$_[1];
				     $n->{filename} !~ /^\.{1,2}$/
				       and ::file_type_format ($n->{a}->perm) eq 'dir';
				   });
  my @dirs = sort map {$_->{filename}} @$ls ;
  return \@dirs;
}

sub sftp_expand_dir {
  my ($view, $iter, $path, $sftp) = @_;
  #Gtk2::TreeView, Gtk2::TreeIter, Gtk2::TreePath
  my $model = $view->get_model;

  my $first_child = $model->iter_children ($iter);
  my $first_val = $model->get_value ($first_child);

  if (! $first_val) {
    # yet not expanded throw sftp

    my $names = sftp_ls ($sftp, tree_path ($view, $iter));

    # remove fictive ''-child
    if (@$names) {
      $model->remove ($first_child);
    }

    for my $n (@$names) {
      my $it = $model->append ($iter);
      $model->set ($it, 0 => $n);
      # add fictive '' children - need for expand dir work
      my $iter_child = $model->append ($it);
      $model->set ($iter_child, 0 => '');
    }
  }
  return FALSE; # need expand
}

sub sftp_browser_create {
  my $sftp = shift;

  my $sw = Gtk2::ScrolledWindow->new (undef, undef);
  $sw->set_shadow_type ('etched-out');
  $sw->set_policy ('automatic', 'automatic');
  $sw->set_size_request (300, 300);
  $sw->set_border_width (5);

  my $model = Gtk2::TreeStore->new (qw/Glib::String/);

  my $names = sftp_ls ($sftp, '/');

  for my $n (@$names) {
    my $iter = $model->append (undef);
    $model->set ($iter, 0 => $n);
    my $iter_child = $model->append ($iter);
    $model->set ($iter_child, 0 => '');
  }

  my $tree_view = Gtk2::TreeView->new ($model);
  $tree_view->signal_connect ('test-expand-row'=>\&sftp_expand_dir, $sftp);
  $tree_view->set ('show-expanders', TRUE);

  my $tree_column = Gtk2::TreeViewColumn->new();

  $tree_column->set_title ("Click to sort");
  my $renderer = Gtk2::CellRendererText->new;
  $tree_column->pack_start ($renderer, FALSE);
  $tree_column->add_attribute ($renderer, text => 0);
  $tree_view->append_column ($tree_column);
  $tree_view->set_expander_column ($tree_column);

  $tree_view->set_search_column (0);
  $tree_column->set_sort_column_id (0);
  $tree_view->set_reorderable(TRUE);
  $sw->add ($tree_view);
  $sw->show_all ();
  return ($sw, $tree_view);
}

sub sftp_connect {
  my ($host, $port, $login, $pass) = @_;
  my $sftp;

  $sftp = Net::SFTP::Foreign->new (host     => $host,
                                   port     => $port,
				   user     => $login,
				   password => $pass);

  if ($sftp->error) {
    ::show_msg ('error', ::text ('SSH connect fail') .":\n" . $sftp->error);
    return undef;
  }
  else {return $sftp}
}

sub sftp_disconnect {
  my $self = shift;

  if ($self->{sftp}) {
    $self->{sftp}->disconnect;
    $self->{sftp} = undef;
    $self->{protocol_label}->set_text ('');
  }
}

sub sftp_run {
  my ($widget, $self) = @_;
  eval {
    require Net::SFTP::Foreign;
    require Net::SFTP::Foreign::Attributes;
  };
  if ($@) {
    ::show_msg ('error', $@);
    return;
  }

  my $dialog = Gtk2::Dialog->new (::text ("SFTP connect") 
				  . ($self->{sftp} ? ' - connected':''),
				  $main_window,
				  ['modal', 'destroy-with-parent'],
                                  'gtk-close' => 'close');
  my $mainbox = Gtk2::VBox->new ();
  $dialog->vbox->add ($mainbox);
  my $table = Gtk2::Table->new (4, 3, FALSE);
  $mainbox->pack_start ($table, FALSE, FALSE, 0);

  my $lb = Gtk2::Label->new (::text ('host'));
  $lb->set_alignment (1.0, 0.5);
  $table->attach ($lb, 0, 1, 0, 1, ['fill'],['expand', 'fill'], 5, 0);
  my $host_entr = Gtk2::Entry->new();
  $table->attach_defaults ($host_entr, 1, 2, 0, 1);

  $lb = Gtk2::Label->new (::text ('port'));
  $lb->set_alignment (1.0, 0.5);
  $table->attach ($lb, 2, 3, 0, 1, ['fill'],['expand', 'fill'], 5, 0);
  my $port_entr = Gtk2::Entry->new();
  $table->attach_defaults ($port_entr, 3, 4, 0, 1);

  $lb = Gtk2::Label->new (::text ('login'));
  $lb->set_alignment (1.0, 0.5);
  $table->attach ($lb, 0, 1, 1, 2, ['fill'],['expand', 'fill'], 5, 0);
  my $login_entr = Gtk2::Entry->new();
  $table->attach_defaults ($login_entr, 1, 2, 1, 2);

  $lb = Gtk2::Label->new (::text ('password'));
  $lb->set_alignment (1.0, 0.5);
  $table->attach ($lb, 2, 3, 1, 2, ['fill'],['expand', 'fill'], 5, 0);
  my $pass_entr = Gtk2::Entry->new();
  $pass_entr->set ('invisible-char', 0x2a);
  $pass_entr->set ('visibility', FALSE);

  $table->attach_defaults ($pass_entr, 3, 4, 1, 2);

  my $status_lb =  Gtk2::Label->new ('Disconnected');
  $mainbox->pack_start ($status_lb, TRUE, TRUE, 0);

  my $status_set = sub {
    my ($host, $login) = @_;
    if ($host) {
      $status_lb->set_markup ("<span weight=\"bold\" foreground=\"red\">"
			      ." Connected to $host as '$login'"
			     . "</span>");
    }
    else {
      $status_lb->set_markup ("<span weight=\"bold\" foreground=\"red\">"
			      . 'Disconnected'
			     . "</span>");
    }
  };

  my $tree;

  my $hbox = Gtk2::HBox->new(TRUE);
  $mainbox->pack_start ($hbox, FALSE, FALSE, 0);

  my $butt =  Gtk2::Button->new (::text ('Connect'));
  $hbox->pack_start ($butt, TRUE, TRUE, 0);
  $butt->signal_connect (clicked =>
			 sub {
			   sftp_disconnect($self->{sftp}) if $self->{sftp};

			   $self->{sftp}  = sftp_connect ($host_entr->get_text,
							  $port_entr->get_text,
							  $login_entr->get_text,
							  $pass_entr->get_text);

			   &$status_set ($host_entr->get_text, $login_entr->get_text);
			 });


  $butt =  Gtk2::Button->new (::text ('Select dir'));
  $hbox->pack_start ($butt, TRUE, TRUE, 0);
  $butt->signal_connect (clicked =>
			 sub {
			   return  if $tree;
			   if ($self->{sftp}) {
			     my $tree_box;
			     ($tree_box, $tree) = sftp_browser_create ($self->{sftp});
			     #$table->attach_defaults ($tree_box, 0, 5, 3, 4);
                             $mainbox->pack_start ($tree_box, TRUE, TRUE, 0);
			   }
			   else {::show_msg ('error', ::text ('Not connected'))}
			 });

  $butt =  Gtk2::Button->new (::text ('Disconnect'));
  $hbox->pack_start ($butt, TRUE, TRUE, 0);
  $butt->signal_connect (clicked =>sub {sftp_disconnect ($self);
					&$status_set()});

  if ($self->{sftp}) {
    $host_entr->set_text ($self->{sftp_host});
    $port_entr->set_text ($self->{sftp_port});
    $login_entr->set_text ($self->{sftp_login});
    $pass_entr->set_text ($self->{sftp_password});
    &$status_set ($self->{sftp_host}, $self->{sftp_login});
  }
  else {
    $port_entr->set_text ('22');
    &$status_set ();
  }

  $dialog->show_all;

  my $response = $dialog->run;

  if ($self->{sftp}) {
    $self->{sftp_host} = $host_entr->get_text;
    $self->{sftp_port} = $port_entr->get_text;
    $self->{sftp_login} = $login_entr->get_text;
    $self->{sftp_password} = $pass_entr->get_text;

    $self->{protocol_label}->set_text ($login_entr->get_text
				       .'@'. $host_entr->get_text);

    if ($tree) {
      my $sel_iter = $tree->get_selection()->get_selected();
      my $dir = tree_path ($tree, $sel_iter);
      $self->{entry}->set_text ($dir);
    }
    else {
      #$self->{entry}->set_text ('/');
    }
  }
  $dialog->destroy;
}

sub set_handler {
  my ($self, $handler) = @_;
  $self->{entry}->signal_connect ('changed' => $handler);
}

sub get {
  my $self = shift;
  my $path = ::envar (::pwd (::home (::rm_sp ($self->{entry}->get_text))));
  $path =~ s/\/$//;
  set ($self, $path);
  return $path;
}

sub sftp {
  my $self = shift;
  return $self ->{sftp};
}

sub set {
  my ($self, $str) = @_;
  $self->{entry}->set_text ($str);
}

sub box {
  my $self = shift;
  return $self ->{box};
}

sub focus {
  my $self = shift;
  return $self ->{entry}->grab_focus;
}
# END Dir_Box ########################################################

package main;
use Encode;
use Glib qw /TRUE FALSE/;
use utf8;
use open ':utf8';
use Gtk2 '-init';
use File::Find;
use File::Copy;
use File::Path;
use File::Basename;
use MIME::Base64 qw(decode_base64);
use File::Compare;
use URI::Escape;

use strict;

my ($start_dir_a, $start_dir_b, $sftp_a);
my ($icon_data, $lang, %local_text, %help_text);

my $dir_box_a;
my $dir_box_b;
my $chk_date;
my $chk_content;
my $chk_size;
my $chk_show_all;
my $progress_bar;
my $main_window = create_window ();

my $break_oper = 0;


init_controls ();

my @tmp_files;

Gtk2->main;
0;

######################################################################
sub create_window {
  my $icon_pixbuf;

  eval {
    my $raw_data = decode_base64 ($icon_data);
    my $pixbufloader = Gtk2::Gdk::PixbufLoader->new;
    $pixbufloader->write ($raw_data);
    $pixbufloader->close;
    $icon_pixbuf = $pixbufloader->get_pixbuf;
  };
  if ($@) {
    print STDERR "error create icon\n";
  }
  undef $icon_data;

  my $window = Gtk2::Window->new ('toplevel');
  $window->signal_connect (destroy => \&on_exit);
  $window->set_border_width (5);
  $window->set_title ($main_title);
  $window->set_size_request (640, 480);

  my $mainbox = Gtk2::VBox->new ();

  $dir_box_a = Dir_Box->new (label => 'A:');
  $dir_box_b = Dir_Box->new (label => 'B:', sftp_disable => 1);

  $mainbox->pack_start ($dir_box_a->box, FALSE, FALSE, 0);
  $mainbox->pack_start ($dir_box_b->box, FALSE, FALSE, 0);

  # кнопки управления
  my $hbox = Gtk2::HBox->new (FALSE, 5);
  my $butt;

  $chk_size = Gtk2::CheckButton->new (text ('size'));
  $chk_size->set_active (TRUE);
  $hbox -> pack_start ($chk_size, FALSE, FALSE, 0);

  $chk_date = Gtk2::CheckButton->new (text ('time'));
  # $chk_date->set_active (TRUE);
  $hbox -> pack_start ($chk_date, FALSE, FALSE, 0);

  $chk_content = Gtk2::CheckButton->new (text ('content'));
  $hbox -> pack_start ($chk_content, FALSE, FALSE, 0);

  $chk_show_all = Gtk2::CheckButton->new (text ('show all'));
  $hbox -> pack_start ($chk_show_all, FALSE, FALSE, 0);

  $mainbox -> pack_start($hbox, FALSE, FALSE, 0);

  # bit flags for control  menu item show
  # 1- need A, 2 - need B, 4 - local (not sftp) files
  my $menu = Menu::create ({caption => 'Select files in dir',
			    handler => \&select_files_in_dir,
			    opt => 0},
			   {caption=> 'Open A',
                            handler => sub {open_handler('a')},
                            opt => 1},
			   {caption=> 'Open B',
                            handler => sub {open_handler('b')},
                            opt => 2},
                           {caption=>'---'},
			   {caption=>'Open A with ..',
			    handler => sub {open_with_dlg ('a')},
			    opt => 1},
			   {caption=>'Open B with ..',
			    handler => sub {open_with_dlg ('b')},
			    opt => 2},
                           {caption=>'---'},
			   {caption=>'Copy A to ..',
			    handler => sub {copy_to_dlg ('a')},
			    opt => 1},
			   {caption=>'Copy B to ..',
			    handler => sub {copy_to_dlg ('b')},
			    opt => 2},
			   {caption=>'---'},
			   {caption=>'Copy A to clipboard',
			    handler => sub {clipboard_copy('a')},
                            opt => 1 | 4},
			   {caption=>'Copy B to clipboard',
			    handler => sub {clipboard_copy('b')},
                            opt => 2},
			   {caption=>'---'},
			   {caption=>'diff A and B',
			    handler => \&diff_files,
			    opt => 1 | 2},
			   {caption=>'comp A and B content ',
			    handler => \&comp_content,
			    opt => 1 | 2});

  #EventBox нужен для корректного позиционировани контекстного меню
  my $eventbox = Gtk2::EventBox->new();
  #$eventbox->set_above_child (TRUE);

  $eventbox->signal_connect('button-release-event' => \&menu_popup, $menu);
  # Result_List использует событие 'button-press-event' для выделения строк
  # его перехватывать нельзя, перехватываем только 'button-release-event'

  $eventbox->add (Result_List::box());

  $mainbox->pack_start ($eventbox, TRUE, TRUE, 0);

#  $progress_bar =Gtk2::ProgressBar->new;
#  $mainbox->pack_start ($progress_bar, FALSE, FALSE, 0);

  # кнопки управления
  $hbox = Gtk2::HBox->new(TRUE);

  my $comp_butt = Gtk2::Button->new (text ('Compare'));
  $hbox->pack_start ($comp_butt, TRUE, TRUE, 0);
  my $exe_butt = Gtk2::Button->new (text ('Execute'));
  $hbox->pack_start ($exe_butt, TRUE, TRUE, 0);

  $exe_butt->signal_connect (clicked => \&operation_do, $comp_butt);
  $comp_butt->signal_connect (clicked => \&start_compare, $exe_butt);


  $butt = Gtk2::Button->new (text ('Help'));
  $butt->signal_connect (clicked => \&show_help, $window);
  $hbox->pack_start ($butt, TRUE, TRUE, 0);

  $butt =  Gtk2::Button->new (text ('Exit'));
  $butt->signal_connect (clicked => \&on_exit, $window);
  $hbox->pack_start ($butt, TRUE, TRUE, 0);

  $mainbox->pack_start($hbox, FALSE, FALSE, 0);

  $window->signal_connect ('key-press-event' => \&window_press_key);

  $window->add ($mainbox);
  $window->show_all;
  # после $main_window->show_all !!
  $window->set_icon ($icon_pixbuf);

  return $window;
}

sub show_msg {
  my ($type, $text) = @_;
  my $butt = 'ok';

  if ($type eq 'question') {
    $butt = 'yes-no';
  }
  my $dialog = Gtk2::MessageDialog->new ($main_window,
                                         'destroy-with-parent',
                                         $type, # message type
                                         $butt, # which set of buttons?
                                         text ($text));

  if ($dialog->run eq 'yes') {
    $dialog->destroy;
    return 1;
  }
  else {
    $dialog->destroy;
    return 0;
  }
}

sub show_text {
  my ($text, $title) = @_;
  my $dialog = Gtk2::Dialog->new ($title,
				  $main_window,
				  ['modal', 'destroy-with-parent'],
				  'gtk-ok'     => 'ok');

  $dialog->set_size_request (640, 480);

  my $textview = Gtk2::TextView->new();
  my $scroll = Gtk2::ScrolledWindow->new;
  $scroll->set_policy ('automatic', 'automatic');
  $scroll->add ($textview);

  $textview->set_editable (FALSE);
  $textview->set_wrap_mode ('word');

  my $buffer = $textview->get_buffer();
  $buffer->set_text ($text);

  $dialog->vbox->add ($scroll);
  $dialog->show_all;
  my $response = $dialog->run;
  $dialog->destroy;
}

sub init_controls {
  Result_List::clear();
  $dir_box_a->set(decode ('utf-8', $ENV{PWD}));
  $dir_box_b->set(decode ('utf-8', $ENV{PWD}));
  $dir_box_a->focus;
}

{
  my $all;
  my $curr;
  my $pb;
  my $dialog;

  sub progress_start {
    my ($files_num, $text) = @_;
    $all = $files_num;
    $dialog = Gtk2::Dialog->new (text ("Please wait") . '...',
				 $main_window,
				 ['modal', 'destroy-with-parent'],
				  'gtk-cancel' => 'cancel');
    $dialog->set_size_request (300, -1);
    $dialog->signal_connect (response => sub {
					      $break_oper = 1;
					      $dialog->destroy()});
    $pb =Gtk2::ProgressBar->new;

    $pb->set_text ($text);
    $pb->set_fraction (0);
    $pb->set_pulse_step (0.01);
    $dialog->vbox->add ($pb);
    $dialog->show_all;
    $break_oper = 0;
  }

  sub progress_reset {
    my ($files_num, $text) = @_;
    $all = $files_num;
    $pb->set_text ($text);
    $pb->set_fraction (0);
    $pb->set_pulse_step (0.01);
  }

  sub progress_next {
    #$progress_bar->set_text ('progress');
    if ($all) {
       $curr++;
       $pb->set_fraction ($curr / $all);
    }
    else {
      $pb->pulse;
    }
  }

  sub progress_end {
    $pb->set_text ('');
    $pb->set_fraction (0);
    $all = $curr = 0;
    $dialog->destroy();
    #$dialog->response ('ok'); - call response-callback - not needed
  }
}

##############################################################################
# обработчики
sub check_path {
  my $d = dirname ($_[0]);

  if (! -d $d) {
    my $dirs = eval {mkpath ($d)};
    return "create dir '$d' error " . decode ('utf-8', $@) . "\n" unless $dirs;
  }
  return undef;
}

sub sftp_check_path {
  my $path = shift;
  my $loop;
  $loop = sub {
    my $p = shift;
    my $d = dirname ($p);
    unless (-d $d) {
      &$loop ($d);
    }
    if ($p eq $path) {
      return undef;
    }
    else {
      my $res = $sftp_a->mkdir($p);
      return "error sftp mkdir '$p':$res:"
	. decode ('utf-8', $sftp_a->error) if not $res;
    };
  };

  &$loop ($path);
}

sub move_or_copy {
  my ($name,  $src, $move) = @_;
  my $path_a =  $start_dir_a . '/' . $name;
  my $path_b =  $start_dir_b . '/' . $name;

  if ($sftp_a) {
    if ($src eq 'a') {
      my $err = check_path ($path_b);
      $err and return $err;

      $sftp_a->get ($path_a, $path_b, overwrite => 1)
	or return "error get remote file '$path_a'\nto '$path_b':"
	  . decode ('utf-8', $sftp_a->error);

      if ($move) {
	$sftp_a->remove ($path_a)
	  or return "error remove remote file '$path_a':"
	    . decode ('utf-8', $sftp_a->error);
      }
    }
    else  {#src=b
      my $err = sftp_check_path ($path_a);
      $err and return $err;

      $sftp_a->put ($path_b, $path_a, overwrite => 1)
	or return "error put file '$path_b' to remote '$path_a':"
	  . decode ('utf-8', $sftp_a->error);

      unlink $path_b or return "error delete local '$path_b'" if $move;
    }
  }
  else { #local copy
    my ($s, $d) = ($src eq 'a' ? ($path_a, $path_b) : ($path_b, $path_a));
    my $err = check_path ($d);
    $err and return $err;

    if ($move) {
      move ($s, $d) or return "move error:'$s'\nto '$d'";
    }
    else {
      copy ($s, $d) or return "copy error:'$s'\nto '$d'";
    }
  }
  return undef;
}

sub oper_copy {
  my ($name,  $src) = @_;
  return move_or_copy ($name,  $src, 0);
}

sub oper_move {
  my ($name,  $src) = @_;
  return move_or_copy ($name,  $src, 1);
}

sub oper_del {
  my ($name, $letter) = @_;
  my $path = ($letter eq 'a' ? $start_dir_a : $start_dir_b)
    . '/' . $name;

  if ($letter eq 'a' and $sftp_a) {
    $sftp_a->remove ($path)
      or return "error remove remote file '$path':" 
	. decode ('utf-8', $sftp_a->error);
  }
  else {
    unlink $path or return "error delete local '$path'"
  }
  return '';
}

sub operation_do {
  my ($err, $too_many_err);

  my $check_err = sub {
    return if $too_many_err or not $_[0];

    if (length ($err) > 2000) {
      $err .= "\n(Too many error)";
      $too_many_err = 1;
    }
    else {
      $err .= "\n" . $_[0];
    }
  };

  # for (my $i = 0; $i < Result_List::row_count(); $i++) {
  #   my %row = Result_List::row ($i);
  #   print "$row{a_cp},$row{a_del},$row{b_cp},$row{b_del}  ",
  #     encode ('utf-8', $row{name}),"\n";
  # }
  # return;

  my @inxes;
  Result_List::get_oper_inx_list (\@inxes);

  return if $#inxes < 0;
  show_msg ('question', 'Execute all operation?') or return;

  progress_start ($#inxes + 1, text ('execution'));

  for my $i (@inxes) {
    last if $too_many_err or $break_oper;

    my %row = Result_List::row ($i);

    if ($row{a_cp} and ! $row{b_cp} and ! $row{b_del}) {
      if (! $row{a_del}) { # copy A->B
        &$check_err (oper_copy ($row{name}, 'a'));
      }
      else { # move A->B
        &$check_err (oper_move ($row{name}, 'a'));
      }
    }
    elsif (! $row{a_cp} and ! $row{a_del} and $row{b_cp}) {
      if (! $row{b_del}) {# copy B->A
	&$check_err (oper_copy ($row{name}, 'b'));
      }
      else {# move B->A
	&$check_err (oper_move ($row{name}, 'b'));
      }
    }
    elsif (! $row{a_cp} and ! $row{b_cp}) {
      if ($row{a_del}) {
	&$check_err (oper_del ($row{name}, 'a'));
      }
      if ($row{b_del}) {
	&$check_err (oper_del ($row{name}, 'b'));
      }
    }
    else {
      $err .= " oper code error for \n$a \n$b\n"
    }
    gui_upd();
  }

  if ($err) {
    show_msg ('error', $err);
  }
  progress_end ();

  start_compare();
}

sub files_uri {
  my @res;
  map {push @res,  'file://' . uri_escape ($_, q( ?<>{}#%`;"))} @_;
  #print "uri:@res\n";
  return @res;
}

sub open_with {
  my ($letter, @cmd) = @_;
  my $dir = ($letter eq 'a' ? $start_dir_a : $start_dir_b);

  my $name = $dir . '/'. Result_List::selected_name();

  if ($sftp_a and $letter eq 'a') {
    $name = eval {
      return sftp_tmp_copy ($sftp_a, $name);
    };
    if ($@) {
      show_msg ("SFTP error:$@\n");
      return;
    }
  }

  if (-f $name) {
    if (not fork) {
      print STDERR "open:@cmd $name\n";
      exec (@cmd, files_uri ($name));
    }
  }
  else {
    show_msg ("File '$name' not exists\n");
  }
}

sub open_handler {
  open_with ($_[0], $open_helper);
}

sub open_with_dlg {
  my $letter = shift;

  my $dialog = Gtk2::Dialog->new (uc ($letter) . ": ". text ("open with"),
				  $main_window,
				  ['modal', 'destroy-with-parent'],
				  'gtk-cancel' => 'cancel',
				  'gtk-ok'     => 'ok');
  #$dialog->set_title (text ('Open ') . $letter . text (' with ..'));

  my $entr = Gtk2::Entry->new;
  $entr->set_width_chars (20);
  $dialog->vbox->add ($entr);

  $dialog->set_default_response ('cancel');
  $dialog->show_all;
  my $response = $dialog->run;

  my @cmd = split /\s+/, $entr->get_text ();
  #print "cmd:@cmd\n";
  $dialog->destroy;
  open_with ($letter, @cmd) if $response eq 'ok';
}

sub copy_to_dlg {
  my $letter = shift;
  my $dialog = Gtk2::Dialog->new (uc ($letter) . ": " . text ("copy to .."),
				  $main_window,
				  ['modal', 'destroy-with-parent'],
				  'gtk-cancel' => 'cancel',
				  'gtk-ok'     => 'ok');
  my $dirbox = Dir_Box->new (label=> '', sftp_disable => 1, butt_size => 50);
  $dialog->vbox->add ($dirbox->box);

  $dialog->set_default_response ('cancel');
  $dialog->show_all;
  my $response = $dialog->run;
  my $name = Result_List::selected_name();
  my $dst = $dirbox->get() . '/' . basename ($name);
  $dialog->destroy;

  if ($response eq 'ok') {
    my $src = ($letter eq 'a'? $start_dir_a: $start_dir_b)
                . '/'. $name;
    #print "copy to:$src->$dst\n";

    if ($sftp_a and $letter eq 'a') {#copy from sftp to local
      my $err = check_path ($dst);
      if ($err) {
	show_msg ('error', $err);
      }
      else {
	$sftp_a->get ($src, $dst, overwrite => 1)
	  or show_msg ('error',
		       "error get remote file '$src'\nto '$dst':"
		       . decode ('utf-8', $sftp_a->error));
      }
    }
    else {#local copy
      copy ($src, $dst) or show_msg ('error', "copy error:'$src'\nto '$dst'");
    }
  }
}

sub diff_files {
  my %row = Result_List::row (Result_List::selected_inx_0());

  if ($row{size_a} > 1E3 or  $row{size_b} > 1E3) {
    show_msg ("File too big");
    return;
  }

  my $path_a =  $dir_box_a->get . '/'. $row{name};
  my $path_b =  $dir_box_b->get . '/'. $row{name};

  if ($sftp_a) {
      $path_a = eval {
      sftp_tmp_copy ($sftp_a, $path_a);
    };
    if ($@) {
      show_msg ("SFTP error:$@\n");
      return;
    }
  }

  open my $fh, '-|', 'diff', '-u', $path_a, $path_b or die "Can't open pipe: $!";
  my $out;
  $out .= $_ while <$fh>;
  close $fh;
  $out ? show_text ($out, "diff:$row{name}")
    : show_msg ('info', text ('no differece found'));
}

sub select_files_in_dir {
  my $file = Result_List::selected_name ();
  print "select_files_in_dir:$file\n";
  my @path = split '/', $file;
  pop @path; # remove file name

  my $dialog = Gtk2::Dialog->new (::text ("Directory synchronization"),
  				  $main_window,
  				  ['modal', 'destroy-with-parent'],
				  'gtk-cancel' => 'cancel',
                                  'gtk-ok' => 'ok');
  my $mainbox = Gtk2::VBox->new (FALSE, 20);
  $dialog->vbox->add ($mainbox);


  my $dir_entr = Gtk2::ComboBox->new_text;
  $mainbox->pack_start ($dir_entr, FALSE, FALSE, 0);

  my $hbox  = Gtk2::HBox->new ();
  $mainbox->pack_start ($hbox, FALSE, FALSE, 0);

  my $pp = '';
  for my $p (@path) {
    $pp .= ($pp ? '/':'') . $p;
    $dir_entr->prepend_text ($pp);
  }
  $dir_entr->set_active (0);


  my %chk = (a_del  => 'del A',
	     b_del  => 'del B',
	     a_cp   => 'A->B',
	     b_cp   => 'B->A');
  my $bt;
  for my $n ('a_cp',  'a_del', 'b_cp', 'b_del') {
    $bt = Gtk2::CheckButton->new ($chk{$n});
    $hbox->pack_start ($bt, FALSE, FALSE, 0);
    $chk{$n} = $bt;
  }

  $chk{'a_cp'}->signal_connect
    (toggled =>
     sub {
       if ($chk{'a_cp'}->get_active) {
	 $chk{'b_cp'}->set_active (FALSE);
	 $chk{'b_del'}->set_active (FALSE);
       }
     });
  $chk{'b_cp'}->signal_connect
    (toggled =>
     sub {
       if ($chk{'b_cp'}->get_active) {
	 $chk{'a_cp'}->set_active (FALSE);
	 $chk{'a_del'}->set_active (FALSE);
       }
     });
  $chk{'a_del'}->signal_connect
    (toggled =>
     sub {
       if ($chk{'a_del'}->get_active) {
	 $chk{'b_cp'}->set_active (FALSE);
       }
     });
  $chk{'b_del'}->signal_connect
    (toggled =>
     sub {
       if ($chk{'b_del'}->get_active) {
	 $chk{'a_cp'}->set_active (FALSE);
       }
     });

  $dialog->show_all;
  my $response = $dialog->run;

  $dialog->destroy;

  if ($response eq 'ok') {
    my $path =  $dir_entr->get_active_text;
    my @checks;
    for my $k (keys %chk) {
      push @checks, $k if $chk{$k}->get_active;
    }
    print "set checks:$path @checks\n";
    Result_List::set_checks_for_dir ($path, @checks)
  }
}

sub gui_upd {
  progress_next ();
  while (Glib::MainContext->default->pending)
    {Glib::MainContext->default->iteration (FALSE)};
}

sub create_local_path_list {
  my ($start_dir, $res) = @_;
  eval {
    my $cnt = 0;
    find ({wanted => sub {
            die if $break_oper;
            return if /^\.\.?$/;
            my $path = decode ('utf8', $File::Find::name);
	    my $p = substr $path, length $start_dir;
            my %attr = get_file_info ($path);
            $res->{$p} = {%attr} if $attr{type} eq 'file';
            gui_upd (), $cnt = 0 if $cnt++ >= 20;
	  }},
	  encode ('utf8', $start_dir));
  };
  if ($@ and ! $break_oper) {
    show_msg ('error', "Find file error: $@\n$start_dir");
  }
}

sub sftp_tmp_copy {
  my ($sftp, $path) = @_;

  require File::Temp;

  my ($name, $dir, $suff) = fileparse ($path,  qr/\.[^.]*$/);
  my $tmp = File::Temp->new( TEMPLATE => "$name-$main_title-sftp-XXXXX",
			     DIR      => '/tmp',
                             SUFFIX   => $suff,
			     UNLINK   => 0);
  $sftp->get ($path, $tmp) or die "error get remote file\n'$path'\nto\n'$tmp'";
  push @tmp_files, {file=>$tmp, orig=>$path, info=>'sftp'};
  return $tmp;
}

sub create_sftp_path_list {
  my ($sftp, $start_dir, $res) = @_;
  eval {
    $sftp->find ($start_dir,
		 wanted =>
		 sub {
                   die if $break_oper;
		   my $f = $_[1];
		   my $n = $f->{filename};
		   my $p = substr $n, length $start_dir;

		   return if ! $p;

		   # name(relative path) => attributes
		   my $type = file_type_format ($f->{a}->perm);
		   $res->{$p} = {type  => $type,
				 size  => num_format ($f->{a}->size),
				 ctime => '',
				 mtime => time_format ($f->{a}->mtime),
				 perm  => perm_format ($f->{a}->perm),
				 owner => $f->{a}->uid . ':' . $f->{a}->gid,
				 other => ''} if $type eq 'file';

		   gui_upd();
		 });
  };
  if ($@ and ! $break_oper) {
    show_msg ('error', "Find remote files error: $@\n$start_dir");
  }
}

sub create_path_list {
  my ($sftp, $start_dir, $res) = @_;
  $sftp ? create_sftp_path_list ($sftp, $start_dir, $res) :
    create_local_path_list ($start_dir, $res);
}

sub comp_content {
  my ($path_a, $path_b) = ($start_dir_a . '/'. Result_List::selected_name(),
			   $start_dir_b . '/'. Result_List::selected_name());

  if ($sftp_a) {
    $path_a = eval {sftp_tmp_copy ($sftp_a, $path_a)};
    if ($@) {
      show_msg ("SFTP error:$@\n");
      return;
    }
  }

  my $res = (compare ($path_a, $path_b) == 0 ?
	     text ("Content is equevalent")
	     : text ("Content is different"));
  show_msg ('info', $res);
}

sub start_compare {
  my $check_date = $chk_date->get_active;
  my $check_content  = $chk_content->get_active;
  my $check_size = $chk_size->get_active;
  my $show_all = $chk_show_all->get_active;

  ($start_dir_a, $start_dir_b) = ($dir_box_a->get, $dir_box_b->get);
  $sftp_a = $dir_box_a->sftp;

  if ($sftp_a and $check_content) {
    show_msg ('error', text ('Check content not available with SFTP'));
    return;
  }
  Result_List::clear();

  !$sftp_a and $start_dir_a ne $start_dir_b || return;

  my (%names_a, %names_b);
  progress_start (0, text ('get file-list') . ' A');
  create_path_list ($sftp_a, $start_dir_a, \%names_a);
  progress_reset (0, text ('get file-list') . ' B');
  create_path_list (undef,   $start_dir_b, \%names_b);
  progress_reset (0, text ('compare dirs'));
  # print "LIST A:\n";
  # map {print encode ('utf-8',$_),"\n"} sort keys %names_a;
  # print "LIST B:\n";
  # map {print encode ('utf-8',$_),"\n"} sort keys %names_b;

  for my $f (keys %names_a) {
    if (! exists $names_b{$f}) {
      Result_List::add ($f, $names_a{$f}, '', 'A');
    }
    else {
      my ($diff);
      $check_size and $names_a{$f}->{size} ne $names_b{$f}->{size} and $diff .= 's';
      $check_date and $names_a{$f}->{mtime} ne $names_b{$f}->{mtime} and $diff .= 't';

      if ($check_content) {
	 $diff .= 'c' if $names_a{$f}->{size} ne $names_b{$f}->{size} or
	   compare ($start_dir_a .'/' . $f, $start_dir_b . '/' . $f);
      }

      ! $diff and $show_all and  $diff = '=';

      Result_List::add ($f, $names_a{$f}, $names_b{$f}, $diff) if $diff;
    }
    progress_next ();
  }

  for my $f (keys %names_b) {
    if (! exists $names_a{$f}) {
      Result_List::add ($f, '', $names_b{$f}, 'B');
    }
    progress_next ();
  }

  progress_end ();

  Result_List::row_count == 0 and ! $break_oper
      and show_msg ('info', text ('No differences were found'));

  Result_List::clear if $break_oper;
}

sub on_exit {
  $break_oper = 1;
  #gui_upd ();
  Gtk2->main_quit;
}

sub menu_popup {
  my ($widget, $event, $menu) = @_;
  my @sel = Result_List::selected_inx();

  if ($#sel == 0 and $event->button == 3) {# только для одной строчки

    my $dtype = Result_List::diff_type ($sel[0]);

    my $patt = 0;
    $patt = 4 if not $sftp_a;
    if ($dtype eq 'A')    {$patt |= 1}
    elsif ($dtype eq 'B') {$patt |= 2}
    else                  {$patt |= 3};

    my $check = sub {my $opt = shift; return ($patt & $opt) == $opt;};
    Menu::show ($menu, $check);
  }
}

sub dir_swap_focus {
  $dir_box_a->focused ? $dir_box_b->focus : $dir_box_a->focus;
}

######################################################################
# обработка клавиатуры
sub window_press_key {
  my ($widget, $event, $parameter)= @_;
  my $key_nr = $event->keyval();
  my $modif =  $event->state();

  if ($modif >= ['control-mask'] and $key_nr == 113) { #ctrl-q
    Gtk2->main_quit;
  }
  return FALSE;
}

sub get_file_info {
  my $name = shift;
  my @par = lstat ($name);
  #print Encode::encode('utf-8',$name), ", par:@par\n";
  #               0 dev      device number of filesystem
  #               1 ino      inode number
  #               2 mode     file mode  (type and permissions)
  #               3 nlink    number of (hard) links to the file
  #               4 uid      numeric user ID of file's owner
  #               5 gid      numeric group ID of file's owner
  #               6 rdev     the device identifier (special files only)
  #               7 size     total size of file, in bytes
  #               8 atime    last access time in seconds since the epoch
  #               9 mtime    last modify time in seconds since the epoch
  #              10 ctime    inode change time in seconds since the epoch (*)
  #              11 blksize  preferred block size for file system I/O
  #              12 blocks   actual number of blocks allocated

  my $type = file_type_format ($par[2]);
  my $info;
  if ($type eq 'l') {
    $info = "-> ". readlink ($name);
  }
  if ($type eq 'c' or $type eq 'b') {
    $info = rdev_format ($par[6]);
  }
  return (type  => $type,
          size  => num_format($par[7]),
          ctime => time_format($par[10]),
          mtime => time_format($par[9]),
          perm  => perm_format($par[2]),
          owner => owner_format($par[4], $par[5]),
          other => $info);
}

# функции форматирования данных для вывода
sub time_format {
  my $tm = shift;
  my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst)
    = localtime($tm);

  return sprintf "%4d-%02d-%02d %02d:%02d:%02d",
                 $year+1900,$mon+1,$mday,$hour,$min,$sec;
}

sub num_format {
  my $x = shift;
  my @a;
  my $i = 3;
  while ($i < length($x)) {
    push @a, substr($x, -$i, 3);
    $i += 3;
  }
  push @a, substr ($x, 0, 3 + length($x) - $i);

  return join '_', reverse @a;
}

sub file_type_format {
  my $tp = shift;
  $tp >>= 12;
  my %type_sym = (8  => 'file',
                  4  => 'dir',
                  10 => 'link',
                  12 => 'sock',
                  1  => 'pipe',
                  2  => 'char',
                  6  => 'block');

  return $type_sym {$tp};
}

sub perm_format {
  my $perm = shift;
  $perm &= 07777;
  return sprintf "%04o", $perm;
}

sub owner_format {
  my ($uid, $gid) = @_;
  my $uname = getpwuid($uid);
  my $gname = getgrgid($gid);
  return ($uname? $uname : $uid) . ':' . ($gname ? $gname : $gid);
}

sub rdev_format {
 return sprintf "%03d,%03d,%03d",
                 ($_[0] >> 16) & 0xff,
                 ($_[0] >> 8) & 0xff,
                  $_[0] & 0xff;
}

sub show_version {
  print "$main_title $VERSION\n";
  exit;
}

## localization #############################################################
sub text {
  my $key = shift;
  $lang eq 'en' and return $key;
  #print "lang:$lang, key:$key->", $local_text {$key}->{$lang}, "\n";
  exists $local_text {$key}->{$lang} ? return $local_text {$key}->{$lang} : return $key;
}

sub get_lang {
  my ($x, $codepage) = split /\./, $ENV{LANG};
  my ($language, $country) = split /_/, $x;

  if ($codepage =~ /utf-?8/i) {
    return lc ($language);
  }
  else {
    return 'en';
  }
}

## Clipboard ################################################################
sub clipboard_copy {
  my $letter = shift;
  my $path;
  my $name = Result_List::selected_name;
  $path = $dir_box_a->get .'/' . $name if $letter eq 'a';
  $path = $dir_box_b->get .'/' . $name if $letter eq 'b';

  my $target_text = {
      target => 'UTF8_STRING', # some string representing the drag type
      flags => [], # Gtk2::TargetFlags
      info => 1,  # some app-defined integer identifier
  };

  my $target_copy_file = {
      target => 'x-special/gnome-copied-files',
      flags => [], # Gtk2::TargetFlags
      info => 2,  # some app-defined integer identifier
  };

  my $clipboard = Gtk2::Clipboard->get (Gtk2::Gdk::Atom->intern ('CLIPBOARD', TRUE));
  $clipboard->set_with_data (\&get_func, \&clear_func, [$path], # need list
                             ($target_text, $target_copy_file));
  $clipboard->store();

  # "PRIMARY" - X selection
  $clipboard = Gtk2::Clipboard->get (Gtk2::Gdk::Atom->intern ('PRIMARY', TRUE));
  $clipboard->set_text ($path);
}


sub get_func {
  my ($clipboard, $selectiondata, $info, $names) = @_;
  my $namestr;
  # нужно экранировать пробелы (хвостовые в первую очередь)
  # и другие символы, минимум это - " #%"
  # аналогично g_file_new_for_path

  $namestr = join "\n", files_uri (@$names);
  # print "info:$info;names:'$namestr'\n";

  if ($info == 1) {
    $selectiondata->set ($selectiondata->target(), 8, join ("\n", @$names));
  }
  if ($info == 2) {
    $selectiondata->set ($selectiondata->target(), 8,
                         "copy\n" . $namestr);
  }
  if ($info == 3) {
    $selectiondata->set ($selectiondata->target(), 8,
                         "cut\n" . $namestr);
    Result_List::delete_item (Result_List::selected_inx_0);
  }
}

sub clear_func {
  my ($self, $path) = @_;
}

#---------------------------------------------------------------------------
# обработка  строки директории

# удаление пробелов и замена специальных символов (имена директорий)
sub rm_sp {
  my $str = shift;
  $str =~ s/^\s+//g;
  $str =~ s/\s+$//g;
  return $str;
}

# замена ~/ домашним каталогом
sub home {
  my $str = shift;
  if ($str =~ /^~\//) {
    $str =~ s/^~/decode ('utf-8', $ENV{HOME})/e;
  }
  return $str;
}

# замена ./ текущим  каталогом
sub pwd {
  my $str = shift;
  if ($str =~ /^\.\//) {
    $str =~ s/^\./decode ('utf-8', $ENV{PWD})/e;
  }
  return $str;
}

# замена переменной окружения $XXX её значением
sub envar {
  my $str = shift;
  if ($str =~ /^\$.+\//) {
    my $var = $&;
    $var =~ s/\/$//;
    $var =~ s/^\$//;
    $str =~ s/^\$.+\//decode ('utf-8', $ENV{$var})/e;
  }
  return $str;
}

sub show_help {
  my $dialog = Gtk2::Dialog->new (text ('Help'),
				  $main_window,
				  ['modal', 'destroy-with-parent'],
				  'gtk-ok'     => 'ok');

  $dialog->set_size_request (640, 480);
  my $textview = Gtk2::TextView->new();
  my $scroll = Gtk2::ScrolledWindow->new;
  $scroll->set_policy ('automatic', 'automatic');
  $scroll->add ($textview);

  $textview->set_editable (FALSE);
  $textview->set_wrap_mode ('word');

  my $buffer = $textview->get_buffer();
  my $head_tag = $buffer->create_tag ('head',
				      'foreground' => '#006600',
				      'weight'     => 900);
  my $start = $buffer->get_start_iter();
  my $end;

  for my $i (@{$help_text{$lang}}) {
    $buffer->insert_with_tags ($start, $i->{title} . "\n\n", $head_tag);
    $buffer->insert ($start, $i->{text} . "\n\n");
  }

  $dialog->vbox->add ($scroll);
  $dialog->show_all;
  my $response = $dialog->run;
  $dialog->destroy;
}


END {
  $dir_box_a->sftp_disconnect if $dir_box_a;
  for my $f (@tmp_files) {
    print STDERR "cleanup tmp:$f->{file}\n";
    unlink $f->{file};
  }
}

BEGIN {
  $icon_data =<<END_ICON;
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBI
WXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3gQZCiMlxEtP2gAAAB1pVFh0Q29tbWVudAAAAAAAQ3Jl
YXRlZCB3aXRoIEdJTVBkLmUHAAACbElEQVRYw+2XX0sUYRTGf+ed2W3XVnMjw9QMUjElW4suQoyu
oosyCMqLwG8Q3fYh+gB+gIgMCqL1A2RG17uaZVGoaatZ/mnVddf583ZhWiquNbNbQh4YGIY5533e
5znPmXdgL/73kLWbjhgXVizu2A5n0JhrzzUQNEGpgqyXEWFAKe7Gk/StA+iI0SkiDy+2NXGpvZlQ
MLCeYRqKx/2fSM1mf6L1GJZtMTM9yZfPk4C+EU/ySK7GqMpZvL9183y4pbEax3E3UiTwemyBF69m
CkO5COlvc4x+eJdRijplO7TUVJaGz548tmVxAK2hoTpCNBLA1auS+AmtNeXRQ4TCoRKtOWW6mvq6
o4exbGfbJNMQrrVXMTqVYXh8gUzO8SWHUoqD0XJSqakGE1CGsXM5Qwn11fs5URtBfHZDIGBwb3mS
8QmU+Wf0gWVr/AqhEdwfJdS/ngN5GdCu/92CIEq8AbDuJ3FefgTlUXMXVFMF+26f88jA4gp6LutP
73T+/Pw94Gr/Iu9QIy8DxukjSCS4Og69TR2kqtQ7ALOtFtpqi+qC3W1D+9kIzvBXPA8+DaqmjMCV
Rm8AnKFpnP4xfy5orsgLIL8ESgogsniXQCJBJBr23ika5EDoNwBsY9VgVyt0tfomQWuNbLbyLx+j
+fRidusLhTx4bqotIqSXsgjMK9MgkXg74WSWc3/NepnsCok3E65hkFC9AwwqYai75zmGoVAiSJEu
pQTDUHQ/6EMphnoHGFw7FZu2w5PSksDlxuOVBANmUXaey1kMj0yxtGw/NQ2ux5NYG8TpiFEJdAJl
RWJ/FuiJJ5nd+yXbNfEddB3KioUXs90AAAAASUVORK5CYII=
END_ICON

  %local_text = ('name'                  => {ru => 'имя'},
		 'diff'                  => {ru => 'отлич'},
		 'perm A'                => {ru => 'права A'},
                 'perm B'                => {ru => 'права B'},
		 'own A'                 => {ru => 'влад A'},
		 'own B'                 => {ru => 'влад B'},
		 'type A'                => {ru => 'тип A'},
		 'type B'                => {ru => 'тип B'},
		 'time A'                => {ru => 'время A'},
		 'time B'                => {ru => 'время B'},
                 'size A'                => {ru => 'размер A'},
                 'size B'                => {ru => 'размер B'},
                 'Compare'               => {ru => 'Сравнить'},
		 'size'                  => {ru => 'размер'},
                 'time'                  => {ru => 'время'},
                 'content'               => {ru => 'содержимое'},
                 'Open A'                => {ru => 'Открыть A'},
		 'Open B'                => {ru => 'Открыть B'},
		 'Copy A to clipboard'   => {ru => 'Копировать A в буфер'},
                 'Copy B to clipboard'   => {ru => 'Копировать B в буфер'},
                 'diff A and B'          => {ru => 'diff A и B'},
		 'comp A and B content ' => {ru => 'Сравнить содержимое A и B'},
                 'Execute'               => {ru => 'Выполнить'},
                 'Exit'                  => {ru => 'Выход'},
                 'Execute all operation?'=> {ru => 'Выполнить все операции?'},
                 'Operation ignored'     => {ru => 'Игнорированы операции'},
                 'Content is equevalent' => {ru => 'Содержимое файлов совпадает'},
		 'Content is different'  => {ru => 'Содержимое файлов отличается'},
		 'copy error'            => {ru => 'Ошибки копирования'},
		 'move error'            => {ru => 'Ошибки перемещения'},
                 'delete error'          => {ru => 'Ошибки удаления'},
		 'show all'              => {ru => 'показать все'},
                 'Help'                  => {ru => 'Справка'},
                 'Abort'                 => {ru => 'Прервать'},
                 'get file-list'         => {ru => 'получаю список файлов'},
                 'compare dirs'          => {ru => 'сравнение директорий'},
                 'Content is equevalent' => {ru => 'Содержимое совпадает'},
                 'Content is different'  => {ru => 'Содержимое отличается'},
                 'Connect'               => {ru => 'Подключиться'},
                 'Select dir'            => {ru => 'Выбрать каталог'},
                 'Disconnect'            => {ru => 'Отключиться'},
                 'Not connected'         => {ru => 'Не подключено'},
		);

  %help_text = (en => [
		       {title => 'Overview',
			text  =>
"Program compares two directories and allows to synchronize them with full manual control."
. "\n One of the directories may be remote and accessible via SFTP."
		       },
		       {title => 'Compare',
			text  =>
"Comparison starts on click 'Compare' button."
. "\nAfter compare succesfull, different files is shown in result list. The 'diff'-column contanes one or more letters which indicate the difference:"
. "\n\tA - file exists only in dir A, B - file exists only in dir B."
. "\nIf one or more options are checked check-boxes 'size', 'time', 'content', "
."There are some options 'size', 'time', 'content'. If one or more options are checked, additional information are compared and it shows
letters"
. "further compares file-attributes and shows letters:"
. "\n\ts\tdifferent size"
. "\n\tt\tdifferent time"
. "\n\tc\tdifferent file content"
. "\n\t=\tdifferents not found,  but checked option 'show all', it allows you to view these files
and test them with any other method."
. "\n Result list shows only ordinary files. Special files (socket, pipe, device) and directories not compares and not shows in result list."
		       },
		       {title => 'Operation',
			text  =>
"After comparing the files, you can copy, move files from one directory to another or delete files."
. " For this you need set checkboxes in result list and click 'Execute' button."
. "\n\tA->B\tcopy file from A into B (with replace file and create path if need)"
. "\n\tdel A\tdelete file from A directory"
. "\nIf for any file selected 'copy' and 'delete' operation, actually will be performed 'move' operation (if it possible)."
		       },
		       {title => 'Remote compare and synchronization (SFTP)',
			text  =>
"For use this feature you need install Net::SFTP::Foreign Perl module. It exists in many Linux repo and CPAN."
. "\nRemote host should allow SSH login."
. "\nGenerally use of SFTP similar to work with local directories, but for diff and view file, "
. "remote file will be downloaded into /tmp."
		       },
		       {title => 'Context menu',
			text  =>
"Context menu (on right-click) provides additional features as diff, view file and copy it into any other directory."
		       },

		      ],
		ru => [
		       {title =>'Общие сведения',
			text  =>
"Программа выполняет сравнение двух директорий по составу файлов и их параметрам"
." и дальнейшую их синхронизацию с полным ручным контролем."
."\nОдна из директорий может быть удалённой и доступной по протоколу SFTP."
		       },
		       {title => 'Сравнение директорий',
			text  =>
"В результирующем списке сравнения показываются только обычные файлы, директории и специальные файлы"
." (файлы устройств, сокеты, каналы) не показываются."
." Также файлы могут быть не показаны, если чтение каталога запрещено данному пользователю."
."\nДля каждого файла в графе 'отлич' проставляются символы, кратко обозначающие найденные отличия."
." Если файл присутствует только в одном каталоге проставляется сответственно символ A или B,"
." в остальных случаях в зависимости от результатов сравнения."
."\nОпции сравнения:"
."\n\t'размер'   \tсравнивать размер файлов, проставляет флажок 's'"
."\n\t'время'    \tсравнивать время модификации файлов (mtime), проставляет флажок 't'"
."\n\t'содержимое'\tсравнивать размер файлов, проставляет флажок 'c'"
."\n\t'показать всё'\tпоказать также файлы отличий в которых не найдено, для них проставляет флажок '='"
		       },
		       {title => 'Операции',
			text  =>
"Операции над файлами (копирование, преремещение, удаление) выбираются установкой флажков:"
."\n\tA->B\tкопировать из директории A в B с заменой"
."\n\tdel A\t удалить файл из директории A"
."\nаналогично два остальных флажка.\nНа локальных каталогах при установки флажков копирования и удаления"
." в действительности выполняется перемещение файла, что часто экономичнее."
."\nВ соответствии с предварительно установленными флажками,"
." по нажатию кнопки 'выполнить' все операции над файлами выполняются."
		      },
		       {title => 'Удалённые сравнения и синхронизация (SFTP)',
			text  =>
"Для использования SFTP должен быть установлен Perl-пакет Net::SFTP::Foreign,"
." обычно это можно сделать посредством пакетного менеджера дистрибутива."
."\nНа удалённой машине должен организован доступ по SSH."
."\nВ целом работа через SFTP аналогична работе с локальными директориями, но для некоторых операций (открытие файла, diff, сравнение содержимого) выполняется скачивание файла с удалённой машины в локальную директорию /tmp."
."\nПри нажатии на кнопку 'SFTP' открывается диалог, позволяющий подключиться к удалённой машине и просмотреть каталоги."
." В случае каких-либо проблем с соединением, попробуйте войти на удалённую машину клиентом SSH и обычным клиентом SFTP,"
. " которые есть в составе любого дистрибутива Linux."

		       },
		       {title => 'Контекстное меню',
			text  =>
"Контекстное меню предоставляет ряд дополнительных возможностей для просмотра файла, уточнения его содержимого и копирования в какой-либо другой каталог, отличный от участвующих в сравнении."
		       },
		      ]);

  $lang = get_lang();
}
