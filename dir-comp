#!/usr/bin/perl
######################################################################
# Copyright (c) 2014-2015 Turishev Evgeniy <ew_turi@mail.ru>
# This file is licensed under the GNU General Public License version 3
# or any later version.
#######################################################################

my $main_title  = 'dir-comp';
my $open_helper = 'exo-open';
my $editor      = 'leafpad';

our $VERSION='1.02';

show_version () if $ARGV[0] eq '-v' or $ARGV[0] eq '--version';

#######################################################################
{
  package Result_List;

  use utf8;
  use Glib qw/TRUE FALSE/;
  use Gtk2::SimpleList;
  use File::Basename;

  my @clmns = ({id=>'name',    caption=>::text ('name'),  type=>'text', align=> 0},
	       {id=>'diff',    caption=>::text ('diff'),  type=>'text', align=> 0.5},
	       {id=>'a_cp',    caption=>'A->B',  type=>'bool', align=> 0.5},
	       {id=>'a_del',   caption=>'del A', type=>'bool', align=> 0.5},
	       {id=>'b_cp',    caption=>'B->A',  type=>'bool', align=> 0.5},
	       {id=>'b_del',   caption=>'del B', type=>'bool', align=> 0.5},
	       {id=>'size_a',  caption=>::text ('size A'),type=>'text', align=> 1},
	       {id=>'size_b',  caption=>::text ('size B'),type=>'text', align=> 1},
	       {id=>'time_a',  caption=>::text ('time A'),type=>'text', align=> 0},
	       {id=>'time_b',  caption=>::text ('time B'),type=>'text', align=> 0},
	       {id=>'perm_a',  caption=>::text ('perm A'),type=>'text', align=> 0},
	       {id=>'perm_b',  caption=>::text ('perm B'),type=>'text', align=> 0},
	       {id=>'owner_a', caption=>::text ('own A'), type=>'text', align=> 0},
	       {id=>'owner_b', caption=>::text ('own B'), type=>'text', align=> 0});

  my %clm; # index columns numbers on id
  for (my $i = 0; $i <= $#clmns; $i++) {
    $clm{$clmns[$i]{id}} = $i;
  }

  my $list;
  my $scroll;
  my @save_selection;

  $list = Gtk2::SimpleList->new (map {($_->{caption}, $_->{type})} @clmns);
  #$list->signal_connect('' => \&Result_List::list_click_hnd);

  for (my $i = 0; $i <= $#clmns; $i++) {
    my $clm = $list -> get_column ($i);
    $clm->set_clickable(TRUE);
    $clm->set_resizable(TRUE);
    $clm->set_sort_column_id($i);

    $clm->signal_connect('clicked', Result_List::click_column_hnd);

    my $r = $clm->get_cell_renderers;


    $r->set('xalign', $clmns[$i]{align});
    if ($clmns[$i]{type} eq 'bool') {
      $r->signal_connect ('toggled' => Result_List::check_box_hnd);
      $clm->set_cell_data_func ($r, \&bool_randr_func);
    }
  }

  $list->get_selection->set_mode ('multiple');
  $list->get_selection->signal_connect ('changed' =>\&Result_List::sel_change_hnd);
  $list->get_model->set_sort_func (8, \&Result_List::sort_int, 8);# sort size A
  $list->get_model->set_sort_func (9, \&Result_List::sort_int, 9);# sort size B

  $scroll = Gtk2::ScrolledWindow->new;
  $scroll -> set_policy ('automatic', 'automatic');
  $scroll -> add ($list);

  $list->signal_connect('button-press-event' => sub {
			  my ($widget,$event) = @_;
			  if ($event->button == 3) {
			    my @sel = Result_List::selected_inx();
			    return TRUE if $#sel > 0;
			    # not propogate event in list
			  }
			  else {FALSE};});

 # restore selection after check box clicked 
 sub sel_change_hnd {
   #my $selection = shift;
   $list->select (@save_selection);
   @save_selection = ();
 }

  # on any cell rendering
 sub bool_randr_func {
    my ($column, $renderer, $model, $iter) = @_;
    my $col = $renderer->{column_index};
    my $id = $clmns[$col]{id};
    my $dtype  = ($model->get ($iter))[$clm{diff}];

    if ($dtype eq 'A' and ($id eq 'b_del' or $id eq 'b_cp')
        or $dtype eq 'B' and ($id eq 'a_del' or $id eq 'a_cp')) {
      $renderer->set('visible' , FALSE);
    }
    else {
      #$renderer->set('inconsistent' , TRUE);
      $renderer->set('visible' , TRUE);
    }
  }

  sub sort_int {
    my $col_num = pop;
    my ($list, @iter) = @_;
    @iter = map {$_ = $list->get($_, $col_num); $_=~s/_//g; $_} @iter;
    return ($iter[0] <=> $iter[1]);
  }

  sub click_column_hnd {
    my ($widget, $data) = @_;
    # print "click_column_hnd\n";
  }

  sub check_box_hnd {
    my ($renderer, $row) = @_;
    my $col = $renderer->{column_index};
    my $model = $list->get_model;
    #print "check_box_hnd:$row,$col\n";

    @save_selection = selected_inx();#save to restore
    my $check_on_sel = 0;

    for my $k (@save_selection) {
      if ($k == $row) {
        # click on in selection area
	$check_on_sel = 1;
	last;
      }
    }

    if ($check_on_sel) {
      $val = $list->{data}->[$row]->[$col];

      if ($#save_selection > 0
	  and $row >= $save_selection[0]
	  and $row <= $save_selection[$#save_selection]) {

	for my $i (@save_selection) {
	  if (col_visible ($i, $col))   {
	    $list->{data}->[$i]->[$col] = $val;
	  }
	}
      }
    }
    else {@save_selection = ()} # delete seletion
  }

  sub clear {
    $list->get_model->clear;
  }

  # добавление результата в список найденного
  sub add {
    my ($name, $info_a, $info_b, $diff) = @_;
    my ($status);

    $name =~ s/^\///;

    $status = $diff;

    # if ($status ne 'A' and $status ne 'B') {
    # 	$status .= ($info_a->{perm} ne  $info_b->{perm} ?'p':'')
    # 	  . ($info_a->{owner} ne  $info_b->{owner} ?'o':'');
    # }

    my @data;
    $data[$clm{name}]    = $name;
    $data[$clm{diff}]    = $status;
    $data[$clm{size_a}]  = $info_a->{size};
    $data[$clm{size_b}]  = $info_b->{size};
    $data[$clm{time_a}]  = $info_a->{mtime};
    $data[$clm{time_b}]  = $info_b->{mtime};
    $data[$clm{perm_a}]  = $info_a->{perm};
    $data[$clm{perm_b}]  = $info_b->{perm};
    $data[$clm{owner_a}] = $info_a->{owner};
    $data[$clm{owner_b}] = $info_b->{owner};
    $data[$clm{a_del}]   = FALSE;
    $data[$clm{b_del}]   = FALSE;
    $data[$clm{a_cp}]    = FALSE;
    $data[$clm{b_cp}]    = FALSE;

    push @{$list->{data}}, [@data];
  }

  sub get_oper_inx_list {
    my $result = shift;
    my $l = $list->{data};
    my $c = row_count();

    for (my $i = 0; $i < $c; $i++) {
      push @$result, $i if $l->[$i]->[$clm{a_del}]
      	or $l->[$i]->[$clm{b_del}]
      	  or $l->[$i]->[$clm{a_cp}]
      	    or $l->[$i]->[$clm{b_cp}];
    }
  }

  sub selected_inx_0 {
    my @sel = $list->get_selected_indices();
    return $sel[0];
  }

  sub selected_inx {
    return $list->get_selected_indices();
  }

  # имя выбранного файла
  sub selected_name {
    my $inx = selected_inx_0();
    return @{$list->{data}}[$inx]->[$clm{name}];
  }

  sub diff_type {
    my $inx = shift;
    return @{$list->{data}}[$inx]->[$clm{diff}];
  }

  sub name {
    return @{$list->{data}}[shift]->[$clm{name}];
  }

  sub row {
    my $inx = shift;
    return map {$_ => @{$list->{data}}[$inx]->[$clm{$_}]} keys %clm;
  }

  sub delete_item {
    my $n = shift;
    splice @{$list->{data}}, $n, 1;
  }

  sub grab_focus {
    $list->grab_focus;
  }

  sub row_count {
    return $#{$list->{data}} + 1;
  }

  sub box {
    return $scroll;
  }

  sub col_visible {
    my ($row, $col) = @_;
    my $dtype = $list->{data}->[$row]->[$clm{diff}];
    return ($dtype ne 'B' or $col != $clm{'a_cp'} and $col != $clm{a_del})
       	  and
       	  ($dtype ne 'A' or $col != $clm{b_cp} and $col != $clm{b_del});
  }

  sub set_checks_for_dir {
    my $path = shift;
    my @checks = @_;

    for (my $i = 0; $i <= $#{$list->{data}}; $i++) {
      my $p = substr $list->{data}->[$i]->[$clm{name}], 0, length $path;

      if ($p eq $path) {
	#print $list->{data}->[$i]->[$clm{name}],  "\n";
        for my $c ('a_cp', 'a_del', 'b_cp', 'b_del') {
	  $list->{data}->[$i]->[$clm{$c}] = FALSE;
	}

        for my $c (@checks) {
	  if (col_visible ($i, $clm{$c})) {
	    $list->{data}->[$i]->[$clm{$c}] = TRUE;
	  }
	}
      }
    }
  }

  sub delete_path_match {
    my $path = shift;

    for (my $i = 0; $i <= $#{$list->{data}}; $i++) {
      my $p = substr $list->{data}->[$i]->[$clm{name}], 0, length $path;

      if ($p eq $path) {
	#print "ig:",$list->{data}->[$i]->[$clm{name}],  "\n";
	delete_item ($i);
      }
    }

    my $model = $list->get_model;
    my $iter = $model->get_iter_first;

    while (defined $iter) {
      my $name = $model->get_value ($iter, $clm{name});
      my $p = substr $name, 0, length $path;

      if ($p eq $path) {
	#print "ig:$name\n";
	my $next = $model->iter_next ($iter);

	$model->remove ($iter);
        $iter = $next;
      } else {$iter = $model->iter_next ($iter)}
    }
  }
}

# END Result_List ####################################################

package Menu;
use utf8;
use Glib qw/TRUE FALSE/;

sub create {
  my $menu = Gtk2::Menu->new;

 # $menu->append (Gtk2::TearoffMenuItem->new);

  while (my $i = shift) {
    my ($item, $name, $handler, $opt);
    $name = $i->{caption};
    $handler = $i->{handler} if exists $i->{handler};

    if (exists $i->{opt}) {
      $opt = $i->{opt}
    }
    else {$opt = 0};

    if ($name eq '---') {
      $item = Gtk2::SeparatorMenuItem->new ();
    }
    else {
      $item = Gtk2::MenuItem->new_with_label (::text ($name));
      $item->signal_connect ('activate' => $handler);
      $item->set_property ('name', $name);
    }

    $item->set_property ('user-data', $opt);
    $menu->append ($item);
  }
  $menu->signal_connect ('hide' => \&Menu::hide);
  $menu->show_all;
  return $menu;
}

sub show {
  my ($menu, $check_callback) = @_;
  my @list = $menu->get_children;

  for my $i (@list) {
    my $ud = $i->get_property ('user-data');
    next if not $ud;

    if (! &$check_callback ($ud)) {
      $i->set_sensitive (FALSE);
    }
  }
  $menu->popup (undef, undef, undef, undef, 0, 0);
}

sub hide {
  my ($menu, $event) = @_;
  my @list = $menu->get_children;
  for my $i (@list) {
    $i->set_sensitive (TRUE);
  }
}

# END Menu ###########################################################
package Dir_Box;
use utf8;
use Glib qw/TRUE FALSE/;

sub new {
  my $class = shift;
  my %opt = @_;

  my $self = {};
  bless ($self, $class);
  $self->{label} = $opt{label};

  my $hbox = Gtk2::HBox->new();
  my $entry = Gtk2::Entry->new;
  $hbox -> pack_end ($entry, TRUE, TRUE, 0);

  my $butt = Gtk2::Button->new ($self->{label});
  $hbox->pack_start ($butt, FALSE, FALSE, 0);
  $butt->signal_connect (clicked => \&Dir_Box::file_dialog_run, $self);
  $butt->set_size_request (50);
  $self->{entry} = $entry;
  $self->{box}   = $hbox;

  return  $self;
}

sub file_dialog_run {
  my ($widget, $self) = @_;
  my $caption = $self->{label};

  my $dialog = Gtk2::FileChooserDialog->new
    (::text ('Select dir') . ' ' . $caption,
     undef,
     'select-folder',
     'gtk-ok'     => 'ok',
     'gtk-cancel' => 'cancel');

  $dialog->set_current_folder ($self->{entry}->get_text);

  my $filter = Gtk2::FileFilter->new;
  $filter->add_mime_type ('inode/directory');

  $dialog->set_filter ($filter);

  if ( $dialog->run eq 'ok') {
    $self->{entry}->set_text ($dialog->get_filename);
  }
  $dialog->destroy;
}

sub tree_path {
  my ($tree_view, $iter) = @_;
  my $model = $tree_view->get_model();
  my $dir_path;

  while ($iter) {
    my $name = $model->get_value ($iter);
    $dir_path = $name . '/' . $dir_path;
    $iter = $model->iter_parent ($iter);
  }
  return '/' . $dir_path;
}

sub set_handler {
  my ($self, $handler) = @_;
  $self->{entry}->signal_connect ('changed' => $handler);
}

sub get {
  my $self = shift;
  my $path = ::envar (::pwd (::home (::rm_sp ($self->{entry}->get_text))));
  $path =~ s/\/$//;
  set ($self, $path);
  return $path;
}

sub set {
  my ($self, $str) = @_;
  $self->{entry}->set_text ($str);
}

sub box {
  my $self = shift;
  return $self ->{box};
}

sub focus {
  my $self = shift;
  return $self ->{entry}->grab_focus;
}
# END Dir_Box ########################################################

package Selector;
use utf8;
use Glib qw/TRUE FALSE/;

sub new {
  my $class = shift;

  my $self = {};
  bless ($self, $class);

  my $hbox = Gtk2::HBox->new();

  my $combo = Gtk2::ComboBox->new_text;
  $hbox -> pack_end ($combo, TRUE, TRUE, 0);

  my @vals;
  while (my $k = shift @_) {
    my $lb = shift;
    $combo->append_text ($lb);
    push @vals, $k;
  }

  $combo->set_active (0);
  $self->{combo} = $combo;
  $self->{box}   = $hbox;
  $self->{vals} = [@vals];

  return  $self;
}

sub set_label {
  my $self = shift;
  my $lb = Gtk2::Label->new(shift);
  $self->box->pack_start ($lb, FALSE, FALSE, 0);
}

sub set_size {
  my $self = shift;
  $self->{combo}->set_size_request (shift);
}

sub box {
  my $self = shift;
  return $self ->{box};
}
# return string value instead indeax in combo or lable text
sub get {
  my $self = shift;
  return $self->{vals}[$self->{combo}->get_active];
}

# END Mode_Selector #################################################


package main;
use Encode;
use Glib qw /TRUE FALSE/;
use utf8;
use open ':utf8';
use Gtk2 '-init';
use File::Find;
use File::Copy;
use File::Path;
use File::Basename;
use MIME::Base64 qw(decode_base64);
use File::Compare;
use URI::Escape;

use strict;

my ($start_dir_a, $start_dir_b);
my ($icon_data, $lang, %local_text, %help_text);

my $dir_box_a;
my $dir_box_b;
my $chk_date;
my $chk_content;
my $chk_size;
my $chk_show_all;
my $progress_bar;
my $mode_box;
my $main_window = create_window ();

my $break_oper = 0;


init_controls ();

my @tmp_files;

Gtk2->main;
0;

######################################################################
sub create_window {
  my $icon_pixbuf;

  eval {
    my $raw_data = decode_base64 ($icon_data);
    my $pixbufloader = Gtk2::Gdk::PixbufLoader->new;
    $pixbufloader->write ($raw_data);
    $pixbufloader->close;
    $icon_pixbuf = $pixbufloader->get_pixbuf;
  };
  if ($@) {
    print STDERR "error create icon\n";
  }
  undef $icon_data;

  my $window = Gtk2::Window->new ('toplevel');
  $window->signal_connect (destroy => \&on_exit);
  $window->set_border_width (5);
  $window->set_title ($main_title);
  $window->set_size_request (640, 480);

  my $mainbox = Gtk2::VBox->new ();

  $dir_box_a = Dir_Box->new (label => 'A');
  $dir_box_b = Dir_Box->new (label => 'B');

  $mainbox->pack_start ($dir_box_a->box, FALSE, FALSE, 0);
  $mainbox->pack_start ($dir_box_b->box, FALSE, FALSE, 0);

  # кнопки управления
  my $hbox = Gtk2::HBox->new (FALSE, 5);

  $mode_box = Selector->new('ab' => 'A <-> B',
			    'a'  => 'A  -> B',
			    'b'  => 'B  -> A');
  #$mode_box -> set_label ('mode');
  #$mode_box -> set_size (80);

  $hbox -> pack_start ($mode_box->box, FALSE, FALSE, 0);


  my $butt;

  $chk_size = Gtk2::CheckButton->new (text ('size'));
  $chk_size->set_active (TRUE);
  $hbox -> pack_start ($chk_size, FALSE, FALSE, 0);

  $chk_date = Gtk2::CheckButton->new (text ('time'));
  # $chk_date->set_active (TRUE);
  $hbox -> pack_start ($chk_date, FALSE, FALSE, 0);

  $chk_content = Gtk2::CheckButton->new (text ('content'));
  $hbox -> pack_start ($chk_content, FALSE, FALSE, 0);

  $chk_show_all = Gtk2::CheckButton->new (text ('show all'));
  $hbox -> pack_start ($chk_show_all, FALSE, FALSE, 0);


  $mainbox -> pack_start($hbox, FALSE, FALSE, 0);

  # bit flags for control  menu item show
  # 1- need A, 2 - need B
  my $menu = Menu::create ({caption => 'Select files in dir',
			    handler => \&select_files_in_dir,
			    opt => 0},
			   {caption => 'Ignore files (dirs)',
			    handler => \&ignore_path,
			    opt => 0},
			   {caption=> 'Open A',
                            handler => sub {open_handler('a')},
                            opt => 1},
			   {caption=> 'Open B',
                            handler => sub {open_handler('b')},
                            opt => 2},
                           {caption=>'---'},
			   {caption=>'Open A with ..',
			    handler => sub {open_with_dlg ('a')},
			    opt => 1},
			   {caption=>'Open B with ..',
			    handler => sub {open_with_dlg ('b')},
			    opt => 2},
                           {caption=>'---'},
			   {caption=>'Copy A to ..',
			    handler => sub {copy_to_dlg ('a')},
			    opt => 1},
			   {caption=>'Copy B to ..',
			    handler => sub {copy_to_dlg ('b')},
			    opt => 2},
			   {caption=>'---'},
			   {caption=>'Copy A to clipboard',
			    handler => sub {clipboard_copy('a')},
                            opt => 1},
			   {caption=>'Copy B to clipboard',
			    handler => sub {clipboard_copy('b')},
                            opt => 2},
			   {caption=>'---'},
			   {caption=>'diff A and B',
			    handler => \&diff_files,
			    opt => 1 | 2},
			   {caption=>'comp A and B content ',
			    handler => \&comp_content,
			    opt => 1 | 2});

  #EventBox нужен для корректного позиционировани контекстного меню
  my $eventbox = Gtk2::EventBox->new();
  #$eventbox->set_above_child (TRUE);

  $eventbox->signal_connect('button-release-event' => \&menu_popup, $menu);
  # Result_List использует событие 'button-press-event' для выделения строк
  # его перехватывать нельзя, перехватываем только 'button-release-event'

  $eventbox->add (Result_List::box());

  $mainbox->pack_start ($eventbox, TRUE, TRUE, 0);

#  $progress_bar =Gtk2::ProgressBar->new;
#  $mainbox->pack_start ($progress_bar, FALSE, FALSE, 0);

  # кнопки управления
  $hbox = Gtk2::HBox->new(TRUE);

  my $comp_butt = Gtk2::Button->new (text ('Compare'));
  $hbox->pack_start ($comp_butt, TRUE, TRUE, 0);
  my $exe_butt = Gtk2::Button->new (text ('Execute'));
  $hbox->pack_start ($exe_butt, TRUE, TRUE, 0);

  $exe_butt->signal_connect (clicked => \&operation_do, $comp_butt);
  $comp_butt->signal_connect (clicked => \&start_compare, $exe_butt);


  $butt = Gtk2::Button->new (text ('Help'));
  $butt->signal_connect (clicked => \&show_help, $window);
  $hbox->pack_start ($butt, TRUE, TRUE, 0);

  $butt =  Gtk2::Button->new (text ('Exit'));
  $butt->signal_connect (clicked => \&on_exit, $window);
  $hbox->pack_start ($butt, TRUE, TRUE, 0);

  $mainbox->pack_start($hbox, FALSE, FALSE, 0);

  $window->signal_connect ('key-press-event' => \&window_press_key);

  $window->add ($mainbox);
  $window->show_all;
  # после $main_window->show_all !!
  $window->set_icon ($icon_pixbuf);

  return $window;
}

sub show_msg {
  my ($type, $text) = @_;
  my $butt = 'ok';

  if ($type eq 'question') {
    $butt = 'yes-no';
  }
  my $dialog = Gtk2::MessageDialog->new ($main_window,
                                         'destroy-with-parent',
                                         $type, # message type
                                         $butt, # which set of buttons?
                                         text ($text));

  if ($dialog->run eq 'yes') {
    $dialog->destroy;
    return 1;
  }
  else {
    $dialog->destroy;
    return 0;
  }
}

sub show_text {
  my ($text, $title) = @_;
  my $dialog = Gtk2::Dialog->new ($title,
				  $main_window,
				  ['modal', 'destroy-with-parent'],
				  'gtk-ok'     => 'ok');

  $dialog->set_size_request (640, 480);

  my $textview = Gtk2::TextView->new();
  my $scroll = Gtk2::ScrolledWindow->new;
  $scroll->set_policy ('automatic', 'automatic');
  $scroll->add ($textview);

  $textview->set_editable (FALSE);
  $textview->set_wrap_mode ('word');

  my $buffer = $textview->get_buffer();
  $buffer->set_text ($text);

  $dialog->vbox->add ($scroll);
  $dialog->show_all;
  my $response = $dialog->run;
  $dialog->destroy;
}

sub init_controls {
  Result_List::clear();
  $dir_box_a->set(decode ('utf-8', $ENV{PWD}));
  $dir_box_b->set(decode ('utf-8', $ENV{PWD}));
  $dir_box_a->focus;
}

{
  my $all;
  my $curr;
  my $pb;
  my $dialog;

  sub progress_start {
    my ($files_num, $text) = @_;
    $all = $files_num;
    $dialog = Gtk2::Dialog->new (text ("Please wait") . '...',
				 $main_window,
				 ['modal', 'destroy-with-parent'],
				  'gtk-cancel' => 'cancel');
    $dialog->set_size_request (300, -1);
    $dialog->signal_connect (response => sub {
					      $break_oper = 1;
					      $dialog->destroy()});
    $pb =Gtk2::ProgressBar->new;

    $pb->set_text ($text);
    $pb->set_fraction (0);
    $pb->set_pulse_step (0.01);
    $dialog->vbox->add ($pb);
    $dialog->show_all;
    $break_oper = 0;
  }

  sub progress_reset {
    my ($files_num, $text) = @_;
    $all = $files_num;
    $pb->set_text ($text);
    $pb->set_fraction (0);
    $pb->set_pulse_step (0.01);
  }

  sub progress_next {
    #$progress_bar->set_text ('progress');
    if ($all) {
       $curr++;
       $pb->set_fraction ($curr / $all);
    }
    else {
      $pb->pulse;
    }
  }

  sub progress_end {
    $pb->set_text ('');
    $pb->set_fraction (0);
    $all = $curr = 0;
    $dialog->destroy();
    #$dialog->response ('ok'); - call response-callback - not needed
  }
}

##############################################################################
# обработчики
sub check_path {
  my $d = dirname ($_[0]);

  if (! -d $d) {
    my $dirs = eval {mkpath ($d)};
    return "create dir '$d' error " . decode ('utf-8', $@) . "\n" unless $dirs;
  }
  return undef;
}

sub move_or_copy {
  my ($name,  $src, $move) = @_;
  my $path_a =  $start_dir_a . '/' . $name;
  my $path_b =  $start_dir_b . '/' . $name;

  my ($s, $d) = ($src eq 'a' ? ($path_a, $path_b) : ($path_b, $path_a));
  my $err = check_path ($d);
  $err and return $err;

  if ($move) {
    move ($s, $d) or return "move error:'$s'\nto '$d'";
  } else {
    copy ($s, $d) or return "copy error:'$s'\nto '$d'";
  }

  return undef;
}

sub oper_copy {
  my ($name,  $src) = @_;
  return move_or_copy ($name,  $src, 0);
}

sub oper_move {
  my ($name,  $src) = @_;
  return move_or_copy ($name,  $src, 1);
}

sub oper_del {
  my ($name, $letter) = @_;
  my $path = ($letter eq 'a' ? $start_dir_a : $start_dir_b)
    . '/' . $name;
  unlink $path or return "error delete local '$path'";

  return '';
}

sub operation_do {
  my ($err, $too_many_err);

  my $check_err = sub {
    return if $too_many_err or not $_[0];

    if (length ($err) > 2000) {
      $err .= "\n(Too many error)";
      $too_many_err = 1;
    }
    else {
      $err .= "\n" . $_[0];
    }
  };

  # for (my $i = 0; $i < Result_List::row_count(); $i++) {
  #   my %row = Result_List::row ($i);
  #   print "$row{a_cp},$row{a_del},$row{b_cp},$row{b_del}  ",
  #     encode ('utf-8', $row{name}),"\n";
  # }
  # return;

  my @inxes;
  Result_List::get_oper_inx_list (\@inxes);

  return if $#inxes < 0;
  show_msg ('question', 'Execute all operation?') or return;

  progress_start ($#inxes + 1, text ('execution'));

  for my $i (@inxes) {
    last if $too_many_err or $break_oper;

    my %row = Result_List::row ($i);

    if ($row{a_cp} and ! $row{b_cp} and ! $row{b_del}) {
      if (! $row{a_del}) { # copy A->B
        &$check_err (oper_copy ($row{name}, 'a'));
      }
      else { # move A->B
        &$check_err (oper_move ($row{name}, 'a'));
      }
    }
    elsif (! $row{a_cp} and ! $row{a_del} and $row{b_cp}) {
      if (! $row{b_del}) {# copy B->A
	&$check_err (oper_copy ($row{name}, 'b'));
      }
      else {# move B->A
	&$check_err (oper_move ($row{name}, 'b'));
      }
    }
    elsif (! $row{a_cp} and ! $row{b_cp}) {
      if ($row{a_del}) {
	&$check_err (oper_del ($row{name}, 'a'));
      }
      if ($row{b_del}) {
	&$check_err (oper_del ($row{name}, 'b'));
      }
    }
    else {
      $err .= " oper code error for \n$a \n$b\n"
    }
    gui_upd();
  }

  if ($err) {
    show_msg ('error', $err);
  }
  progress_end ();

  start_compare();
}

sub files_uri {
  my @res;
  map {push @res,  'file://' . uri_escape ($_, q( ?<>{}#%`;"))} @_;
  #print "uri:@res\n";
  return @res;
}

sub open_with {
  my ($letter, @cmd) = @_;
  my $dir = ($letter eq 'a' ? $start_dir_a : $start_dir_b);

  my $name = $dir . '/'. Result_List::selected_name();

  if (-f $name) {
    if (not fork) {
      print STDERR "open:@cmd $name\n";
      exec (@cmd, files_uri ($name));
    }
  }
  else {
    show_msg ("File '$name' not exists\n");
  }
}

sub open_handler {
  open_with ($_[0], $open_helper);
}

sub open_with_dlg {
  my $letter = shift;

  my $dialog = Gtk2::Dialog->new (uc ($letter) . ": ". text ("open with"),
				  $main_window,
				  ['modal', 'destroy-with-parent'],
				  'gtk-cancel' => 'cancel',
				  'gtk-ok'     => 'ok');
  #$dialog->set_title (text ('Open ') . $letter . text (' with ..'));

  my $entr = Gtk2::Entry->new;
  $entr->set_width_chars (20);
  $dialog->vbox->add ($entr);

  $dialog->set_default_response ('cancel');
  $dialog->show_all;
  my $response = $dialog->run;

  my @cmd = split /\s+/, $entr->get_text ();
  #print "cmd:@cmd\n";
  $dialog->destroy;
  open_with ($letter, @cmd) if $response eq 'ok';
}

sub copy_to_dlg {
  my $letter = shift;
  my $dialog = Gtk2::Dialog->new (uc ($letter) . ": " . text ("copy to .."),
				  $main_window,
				  ['modal', 'destroy-with-parent'],
				  'gtk-cancel' => 'cancel',
				  'gtk-ok'     => 'ok');
  my $dirbox = Dir_Box->new (label=> '');
  $dialog->vbox->add ($dirbox->box);

  $dialog->set_default_response ('cancel');
  $dialog->show_all;
  my $response = $dialog->run;
  my $name = Result_List::selected_name();
  my $dst = $dirbox->get() . '/' . basename ($name);
  $dialog->destroy;

  if ($response eq 'ok') {
    my $src = ($letter eq 'a'? $start_dir_a: $start_dir_b)
                . '/'. $name;
    #print "copy to:$src->$dst\n";
    copy ($src, $dst) or show_msg ('error', "copy error:'$src'\nto '$dst'");
  }
}

sub diff_files {
  my %row = Result_List::row (Result_List::selected_inx_0());

  if ($row{size_a} > 1E3 or  $row{size_b} > 1E3) {
    show_msg ("File too big");
    return;
  }

  my $path_a =  $dir_box_a->get . '/'. $row{name};
  my $path_b =  $dir_box_b->get . '/'. $row{name};

  open my $fh, '-|', 'diff', '-u', $path_a, $path_b or die "Can't open pipe: $!";
  my $out;
  $out .= $_ while <$fh>;
  close $fh;
  $out ? show_text ($out, "diff:$row{name}")
    : show_msg ('info', text ('no differece found'));
}

sub select_files_in_dir {
  my $file = Result_List::selected_name ();
  #print "select_files_in_dir:$file\n";
  my @path = split '/', $file;
  pop @path; # remove file name

  my $dialog = Gtk2::Dialog->new (::text ("Directory synchronization"),
  				  $main_window,
  				  ['modal', 'destroy-with-parent'],
				  'gtk-cancel' => 'cancel',
                                  'gtk-ok' => 'ok');
  my $mainbox = Gtk2::VBox->new (FALSE, 20);
  $dialog->vbox->add ($mainbox);


  my $dir_entr = Gtk2::ComboBox->new_text;
  $mainbox->pack_start ($dir_entr, FALSE, FALSE, 0);

  my $hbox  = Gtk2::HBox->new ();
  $mainbox->pack_start ($hbox, FALSE, FALSE, 0);

  my $pp = '';
  for my $p (@path) {
    $pp .= ($pp ? '/':'') . $p;
    $dir_entr->prepend_text ($pp);
  }
  $dir_entr->set_active (0);

  my %chk = (a_del  => 'del A',
	     b_del  => 'del B',
	     a_cp   => 'A->B',
	     b_cp   => 'B->A');
  my $bt;
  for my $n ('a_cp',  'a_del', 'b_cp', 'b_del') {
    $bt = Gtk2::CheckButton->new ($chk{$n});
    $hbox->pack_start ($bt, FALSE, FALSE, 0);
    $chk{$n} = $bt;
  }

  $chk{'a_cp'}->signal_connect
    (toggled =>
     sub {
       if ($chk{'a_cp'}->get_active) {
	 $chk{'b_cp'}->set_active (FALSE);
	 $chk{'b_del'}->set_active (FALSE);
       }
     });
  $chk{'b_cp'}->signal_connect
    (toggled =>
     sub {
       if ($chk{'b_cp'}->get_active) {
	 $chk{'a_cp'}->set_active (FALSE);
	 $chk{'a_del'}->set_active (FALSE);
       }
     });
  $chk{'a_del'}->signal_connect
    (toggled =>
     sub {
       if ($chk{'a_del'}->get_active) {
	 $chk{'b_cp'}->set_active (FALSE);
       }
     });
  $chk{'b_del'}->signal_connect
    (toggled =>
     sub {
       if ($chk{'b_del'}->get_active) {
	 $chk{'a_cp'}->set_active (FALSE);
       }
     });

  $dialog->show_all;
  my $response = $dialog->run;

  $dialog->destroy;

  if ($response eq 'ok') {
    my $path =  $dir_entr->get_active_text;
    my @checks;
    for my $k (keys %chk) {
      push @checks, $k if $chk{$k}->get_active;
    }
    #print "set checks:$path @checks\n";
    Result_List::set_checks_for_dir ($path, @checks)
  }
}

sub ignore_path {
  my $file = Result_List::selected_name ();

  my @path = split '/', $file;

  my $dialog = Gtk2::Dialog->new (::text ("Directory synchronization"),
  				  $main_window,
  				  ['modal', 'destroy-with-parent'],
				  'gtk-cancel' => 'cancel',
                                  'gtk-ok' => 'ok');
  my $mainbox = Gtk2::VBox->new (FALSE, 20);
  $dialog->vbox->add ($mainbox);


  my $dir_entr = Gtk2::ComboBox->new_text;
  $mainbox->pack_start ($dir_entr, FALSE, FALSE, 0);

  my $hbox  = Gtk2::HBox->new ();
  $mainbox->pack_start ($hbox, FALSE, FALSE, 0);

  my $pp = '';
  for my $p (@path) {
    $pp .= ($pp ? '/':'') . $p;
    $dir_entr->prepend_text ($pp);
  }
  $dir_entr->set_active (0);

  $dialog->show_all;
  my $response = $dialog->run;

  $dialog->destroy;

  if ($response eq 'ok') {
    my $path =  $dir_entr->get_active_text;
    #print "ignore:$path\n";
    Result_List::delete_path_match ($path)
  }
}

sub gui_upd {
  progress_next ();
  while (Glib::MainContext->default->pending)
    {Glib::MainContext->default->iteration (FALSE)};
}

sub create_path_list {
  my ($start_dir, $res) = @_;
  eval {
    my $cnt = 0;
    find ({wanted => sub {
            die if $break_oper;
            return if /^\.\.?$/;
            my $path = decode ('utf8', $File::Find::name);
	    my $p = substr $path, length $start_dir;
            my %attr = get_file_info ($path);
            $res->{$p} = {%attr} if $attr{type} eq 'file';
            gui_upd (), $cnt = 0 if $cnt++ >= 20;
	  }},
	  encode ('utf8', $start_dir));
  };
  if ($@ and ! $break_oper) {
    show_msg ('error', "Find file error: $@\n$start_dir");
  }
}

sub comp_content {
  my ($path_a, $path_b) = ($start_dir_a . '/'. Result_List::selected_name(),
			   $start_dir_b . '/'. Result_List::selected_name());

  my $res = (compare ($path_a, $path_b) == 0 ?
	     text ("Content is equevalent")
	     : text ("Content is different"));
  show_msg ('info', $res);
}

sub start_compare {
  my $check_date = $chk_date->get_active;
  my $check_content  = $chk_content->get_active;
  my $check_size = $chk_size->get_active;
  my $show_all = $chk_show_all->get_active;

  ($start_dir_a, $start_dir_b) = ($dir_box_a->get, $dir_box_b->get);

  Result_List::clear();

  $start_dir_a ne $start_dir_b || return;

  my $comp_mode = $mode_box->get;

  my (%names_a, %names_b);

  progress_start (0, text ('get file-list') . ' A');
  create_path_list ($start_dir_a, \%names_a);
  progress_reset (0, text ('get file-list') . ' B');
  create_path_list ($start_dir_b, \%names_b);

  progress_reset (0, text ('compare dirs'));
  # print "LIST A:\n";
  # map {print encode ('utf-8',$_),"\n"} sort keys %names_a;
  # print "LIST B:\n";
  # map {print encode ('utf-8',$_),"\n"} sort keys %names_b;

  progress_reset (0, text ('start compare'));

  my ($base_list, $other_list, $base_letter, $other_letter);
  if ($comp_mode eq 'b') {
    $base_list = \%names_b;
    $other_list = \%names_a;
    $base_letter = 'B';
    $other_letter = 'A';

  } else {
    $base_list = \%names_a;
    $other_list = \%names_b;
    $base_letter = 'A';
    $other_letter = 'B';
  }

  for my $f (keys %$base_list) {
    if (! exists $other_list->{$f}) {
      Result_List::add ($f, $base_list->{$f}, '', $base_letter);
    } else {
      my ($diff);
      $check_size and $names_a{$f}->{size} ne $names_b{$f}->{size} and $diff .= 's';
      $check_date and $names_a{$f}->{mtime} ne $names_b{$f}->{mtime} and $diff .= 't';

      if ($check_content) {
	$diff .= 'c' if $names_a{$f}->{size} ne $names_b{$f}->{size} or
	  compare ($start_dir_a .'/' . $f, $start_dir_b . '/' . $f);
      }

      ! $diff and $show_all and  $diff = '=';

      Result_List::add ($f, $names_a{$f}, $names_b{$f}, $diff) if $diff;
    }
    progress_next ();
  }

  if ($comp_mode eq 'ab') {
    for my $f (keys %$other_list) {
      if (! exists $base_list->{$f}) {
	Result_List::add ($f, '', $other_list->{$f}, $other_letter);
      }
      progress_next ();
    }
  }

  progress_end ();

  Result_List::row_count == 0 and ! $break_oper
      and show_msg ('info', text ('No differences were found'));

  Result_List::clear if $break_oper;
}

sub on_exit {
  $break_oper = 1;
  #gui_upd ();
  Gtk2->main_quit;
}

sub menu_popup {
  my ($widget, $event, $menu) = @_;
  my @sel = Result_List::selected_inx();

  if ($#sel == 0 and $event->button == 3) {# только для одной строчки

    my $dtype = Result_List::diff_type ($sel[0]);

    my $patt = 0;

    if ($dtype eq 'A')    {$patt |= 1}
    elsif ($dtype eq 'B') {$patt |= 2}
    else                  {$patt |= 3};

    my $check = sub {my $opt = shift; return ($patt & $opt) == $opt;};
    Menu::show ($menu, $check);
  }
}

sub dir_swap_focus {
  $dir_box_a->focused ? $dir_box_b->focus : $dir_box_a->focus;
}

######################################################################
# обработка клавиатуры
sub window_press_key {
  my ($widget, $event, $parameter)= @_;
  my $key_nr = $event->keyval();
  my $modif =  $event->state();

  if ($modif >= ['control-mask'] and $key_nr == 113) { #ctrl-q
    Gtk2->main_quit;
  }
  return FALSE;
}

sub get_file_info {
  my $name = shift;
  my @par = lstat ($name);
  #print Encode::encode('utf-8',$name), ", par:@par\n";
  #               0 dev      device number of filesystem
  #               1 ino      inode number
  #               2 mode     file mode  (type and permissions)
  #               3 nlink    number of (hard) links to the file
  #               4 uid      numeric user ID of file's owner
  #               5 gid      numeric group ID of file's owner
  #               6 rdev     the device identifier (special files only)
  #               7 size     total size of file, in bytes
  #               8 atime    last access time in seconds since the epoch
  #               9 mtime    last modify time in seconds since the epoch
  #              10 ctime    inode change time in seconds since the epoch (*)
  #              11 blksize  preferred block size for file system I/O
  #              12 blocks   actual number of blocks allocated

  my $type = file_type_format ($par[2]);
  my $info;
  if ($type eq 'l') {
    $info = "-> ". readlink ($name);
  }
  if ($type eq 'c' or $type eq 'b') {
    $info = rdev_format ($par[6]);
  }
  return (type  => $type,
          size  => num_format($par[7]),
          ctime => time_format($par[10]),
          mtime => time_format($par[9]),
          perm  => perm_format($par[2]),
          owner => owner_format($par[4], $par[5]),
          other => $info);
}

# функции форматирования данных для вывода
sub time_format {
  my $tm = shift;
  my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst)
    = localtime($tm);

  return sprintf "%4d-%02d-%02d %02d:%02d:%02d",
                 $year+1900,$mon+1,$mday,$hour,$min,$sec;
}

sub num_format {
  my $x = shift;
  my @a;
  my $i = 3;
  while ($i < length($x)) {
    push @a, substr($x, -$i, 3);
    $i += 3;
  }
  push @a, substr ($x, 0, 3 + length($x) - $i);

  return join '_', reverse @a;
}

sub file_type_format {
  my $tp = shift;
  $tp >>= 12;
  my %type_sym = (8  => 'file',
                  4  => 'dir',
                  10 => 'link',
                  12 => 'sock',
                  1  => 'pipe',
                  2  => 'char',
                  6  => 'block');

  return $type_sym {$tp};
}

sub perm_format {
  my $perm = shift;
  $perm &= 07777;
  return sprintf "%04o", $perm;
}

sub owner_format {
  my ($uid, $gid) = @_;
  my $uname = getpwuid($uid);
  my $gname = getgrgid($gid);
  return ($uname? $uname : $uid) . ':' . ($gname ? $gname : $gid);
}

sub rdev_format {
 return sprintf "%03d,%03d,%03d",
                 ($_[0] >> 16) & 0xff,
                 ($_[0] >> 8) & 0xff,
                  $_[0] & 0xff;
}

sub show_version {
  print "$main_title $VERSION\n";
  exit;
}

## localization #############################################################
sub text {
  my $key = shift;
  $lang eq 'en' and return $key;
  #print "lang:$lang, key:$key->", $local_text {$key}->{$lang}, "\n";
  exists $local_text {$key}->{$lang} ? return $local_text {$key}->{$lang} : return $key;
}

sub get_lang {
  my ($x, $codepage) = split /\./, $ENV{LANG};
  my ($language, $country) = split /_/, $x;

  if ($codepage =~ /utf-?8/i) {
    return lc ($language);
  }
  else {
    return 'en';
  }
}

## Clipboard ################################################################
sub clipboard_copy {
  my $letter = shift;
  my $path;
  my $name = Result_List::selected_name;
  $path = $dir_box_a->get .'/' . $name if $letter eq 'a';
  $path = $dir_box_b->get .'/' . $name if $letter eq 'b';

  my $target_text = {
      target => 'UTF8_STRING', # some string representing the drag type
      flags => [], # Gtk2::TargetFlags
      info => 1,  # some app-defined integer identifier
  };

  my $target_copy_file = {
      target => 'x-special/gnome-copied-files',
      flags => [], # Gtk2::TargetFlags
      info => 2,  # some app-defined integer identifier
  };

  my $clipboard = Gtk2::Clipboard->get (Gtk2::Gdk::Atom->intern ('CLIPBOARD', TRUE));
  $clipboard->set_with_data (\&get_func, \&clear_func, [$path], # need list
                             ($target_text, $target_copy_file));
  $clipboard->store();

  # "PRIMARY" - X selection
  $clipboard = Gtk2::Clipboard->get (Gtk2::Gdk::Atom->intern ('PRIMARY', TRUE));
  $clipboard->set_text ($path);
}


sub get_func {
  my ($clipboard, $selectiondata, $info, $names) = @_;
  my $namestr;
  # нужно экранировать пробелы (хвостовые в первую очередь)
  # и другие символы, минимум это - " #%"
  # аналогично g_file_new_for_path

  $namestr = join "\n", files_uri (@$names);
  # print "info:$info;names:'$namestr'\n";

  if ($info == 1) {
    $selectiondata->set ($selectiondata->target(), 8, join ("\n", @$names));
  }
  if ($info == 2) {
    $selectiondata->set ($selectiondata->target(), 8,
                         "copy\n" . $namestr);
  }
  if ($info == 3) {
    $selectiondata->set ($selectiondata->target(), 8,
                         "cut\n" . $namestr);
    Result_List::delete_item (Result_List::selected_inx_0);
  }
}

sub clear_func {
  my ($self, $path) = @_;
}

#---------------------------------------------------------------------------
# обработка  строки директории

# удаление пробелов и замена специальных символов (имена директорий)
sub rm_sp {
  my $str = shift;
  $str =~ s/^\s+//g;
  $str =~ s/\s+$//g;
  return $str;
}

# замена ~/ домашним каталогом
sub home {
  my $str = shift;
  if ($str =~ /^~\//) {
    $str =~ s/^~/decode ('utf-8', $ENV{HOME})/e;
  }
  return $str;
}

# замена ./ текущим  каталогом
sub pwd {
  my $str = shift;
  if ($str =~ /^\.\//) {
    $str =~ s/^\./decode ('utf-8', $ENV{PWD})/e;
  }
  return $str;
}

# замена переменной окружения $XXX её значением
sub envar {
  my $str = shift;
  if ($str =~ /^\$.+\//) {
    my $var = $&;
    $var =~ s/\/$//;
    $var =~ s/^\$//;
    $str =~ s/^\$.+\//decode ('utf-8', $ENV{$var})/e;
  }
  return $str;
}

sub show_help {
  my $dialog = Gtk2::Dialog->new (text ('Help'),
				  $main_window,
				  ['modal', 'destroy-with-parent'],
				  'gtk-ok'     => 'ok');

  $dialog->set_size_request (640, 480);
  my $textview = Gtk2::TextView->new();
  my $scroll = Gtk2::ScrolledWindow->new;
  $scroll->set_policy ('automatic', 'automatic');
  $scroll->add ($textview);

  $textview->set_editable (FALSE);
  $textview->set_wrap_mode ('word');

  my $buffer = $textview->get_buffer();
  my $head_tag = $buffer->create_tag ('head',
				      'foreground' => '#006600',
				      'weight'     => 900);
  my $start = $buffer->get_start_iter();
  my $end;

  for my $i (@{$help_text{$lang}}) {
    $buffer->insert_with_tags ($start, $i->{title} . "\n\n", $head_tag);
    $buffer->insert ($start, $i->{text} . "\n\n");
  }

  $dialog->vbox->add ($scroll);
  $dialog->show_all;
  my $response = $dialog->run;
  $dialog->destroy;
}


BEGIN {
  $icon_data =<<END_ICON;
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBI
WXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3gQZCiMlxEtP2gAAAB1pVFh0Q29tbWVudAAAAAAAQ3Jl
YXRlZCB3aXRoIEdJTVBkLmUHAAACbElEQVRYw+2XX0sUYRTGf+ed2W3XVnMjw9QMUjElW4suQoyu
oosyCMqLwG8Q3fYh+gB+gIgMCqL1A2RG17uaZVGoaatZ/mnVddf583ZhWiquNbNbQh4YGIY5533e
5znPmXdgL/73kLWbjhgXVizu2A5n0JhrzzUQNEGpgqyXEWFAKe7Gk/StA+iI0SkiDy+2NXGpvZlQ
MLCeYRqKx/2fSM1mf6L1GJZtMTM9yZfPk4C+EU/ySK7GqMpZvL9183y4pbEax3E3UiTwemyBF69m
CkO5COlvc4x+eJdRijplO7TUVJaGz548tmVxAK2hoTpCNBLA1auS+AmtNeXRQ4TCoRKtOWW6mvq6
o4exbGfbJNMQrrVXMTqVYXh8gUzO8SWHUoqD0XJSqakGE1CGsXM5Qwn11fs5URtBfHZDIGBwb3mS
8QmU+Wf0gWVr/AqhEdwfJdS/ngN5GdCu/92CIEq8AbDuJ3FefgTlUXMXVFMF+26f88jA4gp6LutP
73T+/Pw94Gr/Iu9QIy8DxukjSCS4Og69TR2kqtQ7ALOtFtpqi+qC3W1D+9kIzvBXPA8+DaqmjMCV
Rm8AnKFpnP4xfy5orsgLIL8ESgogsniXQCJBJBr23ika5EDoNwBsY9VgVyt0tfomQWuNbLbyLx+j
+fRidusLhTx4bqotIqSXsgjMK9MgkXg74WSWc3/NepnsCok3E65hkFC9AwwqYai75zmGoVAiSJEu
pQTDUHQ/6EMphnoHGFw7FZu2w5PSksDlxuOVBANmUXaey1kMj0yxtGw/NQ2ux5NYG8TpiFEJdAJl
RWJ/FuiJJ5nd+yXbNfEddB3KioUXs90AAAAASUVORK5CYII=
END_ICON

  %local_text = ('name'                  => {ru => 'имя'},
		 'diff'                  => {ru => 'отлич'},
		 'perm A'                => {ru => 'права A'},
                 'perm B'                => {ru => 'права B'},
		 'own A'                 => {ru => 'влад A'},
		 'own B'                 => {ru => 'влад B'},
		 'type A'                => {ru => 'тип A'},
		 'type B'                => {ru => 'тип B'},
		 'time A'                => {ru => 'время A'},
		 'time B'                => {ru => 'время B'},
                 'size A'                => {ru => 'размер A'},
                 'size B'                => {ru => 'размер B'},
                 'Compare'               => {ru => 'Сравнить'},
		 'size'                  => {ru => 'размер'},
                 'time'                  => {ru => 'время'},
                 'content'               => {ru => 'содержимое'},
                 'Open A'                => {ru => 'Открыть A'},
		 'Open B'                => {ru => 'Открыть B'},
		 'Copy A to clipboard'   => {ru => 'Копировать A в буфер'},
                 'Copy B to clipboard'   => {ru => 'Копировать B в буфер'},
                 'diff A and B'          => {ru => 'diff A и B'},
		 'comp A and B content ' => {ru => 'Сравнить содержимое A и B'},
                 'Execute'               => {ru => 'Выполнить'},
                 'Exit'                  => {ru => 'Выход'},
                 'Execute all operation?'=> {ru => 'Выполнить все операции?'},
                 'Operation ignored'     => {ru => 'Игнорированы операции'},
                 'Content is equevalent' => {ru => 'Содержимое файлов совпадает'},
		 'Content is different'  => {ru => 'Содержимое файлов отличается'},
		 'copy error'            => {ru => 'Ошибки копирования'},
		 'move error'            => {ru => 'Ошибки перемещения'},
                 'delete error'          => {ru => 'Ошибки удаления'},
		 'show all'              => {ru => 'показать все'},
                 'Help'                  => {ru => 'Справка'},
                 'Abort'                 => {ru => 'Прервать'},
                 'get file-list'         => {ru => 'получаю список файлов'},
                 'compare dirs'          => {ru => 'сравнение директорий'},
                 'Content is equevalent' => {ru => 'Содержимое совпадает'},
                 'Content is different'  => {ru => 'Содержимое отличается'},
                 'Connect'               => {ru => 'Подключиться'},
                 'Select dir'            => {ru => 'Выбрать каталог'},
                 'Disconnect'            => {ru => 'Отключиться'},
                 'Not connected'         => {ru => 'Не подключено'},
		);

  %help_text = (en => [
		       {title => 'Overview',
			text  =>
"Program compares two directories and allows to synchronize them with full manual control."
. "\n For remote sychronisation need mount a remote directory into the local filesystem."
		       },
		       {title => 'Compare',
			text  =>
"Comparison starts on click 'Compare' button."
. "\nAfter compare succesfull, different files is shown in result list. The 'diff'-column contanes one or more letters which indicate the difference:"
. "\n\tA - file exists only in dir A, B - file exists only in dir B."
. "\nIf one or more options are checked check-boxes 'size', 'time', 'content', "
."There are some options 'size', 'time', 'content'. If one or more options are checked, additional information are compared and it shows
letters"
. "further compares file-attributes and shows letters:"
. "\n\ts\tdifferent size"
. "\n\tt\tdifferent time"
. "\n\tc\tdifferent file content"
. "\n\t=\tdifferents not found,  but checked option 'show all', it allows you to view these files
and test them with any other method."
. "\n Result list shows only ordinary files. Special files (socket, pipe, device) and directories not compares and not shows in result list."
		       },
		       {title => 'Operation',
			text  =>
"After comparing the files, you can copy, move files from one directory to another or delete files."
. " For this you need set checkboxes in result list and click 'Execute' button."
. "\n\tA->B\tcopy file from A into B (with replace file and create path if need)"
. "\n\tdel A\tdelete file from A directory"
. "\nIf for any file selected 'copy' and 'delete' operation, actually will be performed 'move' operation (if it possible)."
		       },
		       {title => 'Context menu',
			text  =>
"Context menu (on right-click) provides additional features as diff, view file and copy it into any other directory."
		       },

		      ],
		ru => [
		       {title =>'Общие сведения',
			text  =>
"Программа выполняет сравнение двух директорий по составу файлов и их параметрам"
." и дальнейшую их синхронизацию с полным ручным контролем."
."\nДля сравнениия локальной директории с директорией на другом компьютере нужно смонтировать удалённую файловую систему, например, с помощью gvfs-mount."
		       },
		       {title => 'Сравнение директорий',
			text  =>
"Выпадающий список слева устанавливает режим синхронизации двухстронняя или односторонняя (A<->B, A->B, B->A). В случае двухсторонней синхронизации в с списке отличий будут показываться файлы отсутствующие в ЛЮБОЙ из двух директорий или отличающиеся параметрами (в соответствии с установленными флажками). Это режим по умолчанию. В случае одностороней синхронизации, например A->B, учитываются только те файлы, которые присутствуют в директории A. Это позволяет сократить список, ускорить сравнение и операции и уменьшить использование ресурсов."
. "\n\nВ результирующем списке сравнения показываются только обычные файлы, директории и специальные файлы"
." (файлы устройств, сокеты, каналы) не показываются."
." Также файлы могут быть не показаны, если чтение каталога запрещено данному пользователю."
."\n\nДля каждого файла в графе 'отлич' проставляются символы, кратко обозначающие найденные отличия."
." Если файл присутствует только в одном каталоге проставляется сответственно символ A или B,"
." в остальных случаях в зависимости от результатов сравнения."
."\nОпции сравнения:"
."\n\t'размер'   \tсравнивать размер файлов, проставляется флажок 's'"
."\n\t'время'    \tсравнивать время модификации файлов (mtime), проставляется флажок 't'"
."\n\t'содержимое'\tсравнивать размер файлов, проставляется флажок 'c'"
."\n\t'показать всё'\tпоказать также файлы отличий в которых не найдено, для них проставляется флажок '='"
		       },
		       {title => 'Операции',
			text  =>
"Операции над файлами (копирование, преремещение, удаление) выбираются установкой флажков:"
."\n\tA->B\tкопировать из директории A в B с заменой"
."\n\tdel A\t удалить файл из директории A"
."\nаналогично два остальных флажка.\nНа локальных каталогах при установки флажков копирования и удаления"
." в действительности выполняется перемещение файла, что часто экономичнее."
."\nВ соответствии с предварительно установленными флажками,"
." по нажатию кнопки 'выполнить' все операции над файлами выполняются."
		      },
		       {title => 'Контекстное меню',
			text  =>
"Контекстное меню предоставляет ряд дополнительных возможностей для просмотра файла, уточнения его содержимого и копирования в какой-либо другой каталог, отличный от участвующих в сравнении."
		       },
		      ]);

  $lang = get_lang();
}
